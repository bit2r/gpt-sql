---
editor: 
  markdown: 
    wrap: sentence
---

## 필터

데이터베이스의 가장 강력한 기능 중 하나는 데이터를 **필터(filter)**하는 능력이다.
즉, 특정 기준에 맞는 레코드만 선택한다.
예를 들어, 특정 사이트를 언제 방문했는지 확인한다고 가정하자.
쿼리에 `where` 절을 사용해서 `Visited` 테이블로부터 조건에 맞는 레코드만 뽑아낼 수 있다.

``` sql
SELECT * FROM Visited WHERE site = 'DR-1';
```

| id  | site |   dated    |
|:---:|:----:|:----------:|
| 619 | DR-1 | 1927-02-08 |
| 622 | DR-1 | 1927-02-10 |
| 844 | DR-1 | 1932-03-22 |

데이터베이스 관리자는 이 쿼리를 두 단계로 실행한다.
먼저, `Visited` 테이블 각 행을 확인하여 `WHERE` 조건을 만족하는 행을 찾는다.
그 다음, `SELECT` 키워드 뒤에 따라오는 칼럼 이름을 사용하여 표시할 칼럼을 결정한다.

이러한 처리 순서가 의미하는 바는 화면에 표시되지 않는 칼럼 값에 기반해서도 `WHERE` 절을 사용해서 레코드를 필터링할 수 있다는 것이다.

``` sql
SELECT id FROM Visited WHERE site = 'DR-1';
```

| id  |
|:---:|
| 619 |
| 622 |
| 844 |

![SQL 필터링 동작방식](images/sql-filter.svg)

## 부울 연산자

데이터를 필터링할 때 부울 연산자(Boolean Operators)를 사용한다.
이는 특정 조건을 만족하는 데이터를 선택하거나 제외하는 데 유용하다.
예를 들어, `DR-1` 사이트에서 1930년 이후로 수집된 모든 정보를 요청하는 경우, 부울 연산자를 사용하여 '사이트 이름이 DR-1이고, 수집 연도가 1930년 이후인' 데이터를 필터링할 수 있다.
이렇게 SQL 쿼리에서 부울 연산자를 사용하면, 복잡한 데이터 집합에서 필요한 정보를 정확하고 효율적으로 추출할 수 있다.

``` sql
SELECT * FROM Visited WHERE site = 'DR-1' AND dated < '1930-01-01';
```

| id  | site |   dated    |
|:---:|:----:|:----------:|
| 619 | DR-1 | 1927-02-08 |
| 622 | DR-1 | 1927-02-10 |

::: callout-note
## 날짜 자료형

거의 모든 데이터베이스 관리자는 날짜 자료 처리를 위한 특별한 자료형(Data Type)을 가지고 있다.
실제로 많은 데이터베이스는 크게 두개로 갈린다.
하나는 "1971년 5월 31일"과 같은 날짜용이고, 다른 하나는 "31일"과 같은 기간용(duration)이다.
하지만, `SQLite`는 그렇지 않다.
대신, `SQLite`는 날짜를 텍스트(ISO-8601 표준 형식 "YYYY-MM-DD HH:MM:SS.SSSS"), 실수([율리우스 일자](https://en.wikipedia.org/wiki/Julian_day), 기원전 4714년 11월 24일부터 일수), 또는 정수([유닉스 시간](https://en.wikipedia.org/wiki/Unix_time), 1970년 1월 1일 자정 이후의 초 수)로 저장한다.
만약 복잡하게 들린다면, 그럴수도 있다 하지만 [옛날 스웨덴 날짜](https://en.wikipedia.org/wiki/Swedish_calendar)를 파악하는 것만큼 복잡하지는 않다.
:::

Lake나 Roerich에 의해 수행된 측정이 무엇인지 알아보려면, 그들의 이름에 대한 검사를 `OR`를 사용하여 결합한다.

``` sql
SELECT * FROM Survey WHERE person = 'lake' OR person = 'roe';
```

| taken | person | quant | reading |
|:-----:|:------:|:-----:|:-------:|
|  734  |  lake  |  sal  |  0.05   |
|  751  |  lake  |  sal  |   0.1   |
|  752  |  lake  |  rad  |  2.19   |
|  752  |  lake  |  sal  |  0.09   |
|  752  |  lake  | temp  |  -16.0  |
|  752  |  roe   |  sal  |  41.6   |
|  837  |  lake  |  rad  |  1.46   |
|  837  |  lake  |  sal  |  0.21   |
|  837  |  roe   |  sal  |  22.5   |
|  844  |  roe   |  rad  |  11.25  |

다른 방식으로, `IN`을 사용하여 특정 집합에 값이 있는지 확인할 수 있다.

``` sql
SELECT * FROM Survey WHERE person IN ('lake', 'roe');
```

| taken | person | quant | reading |
|:-----:|:------:|:-----:|:-------:|
|  734  |  lake  |  sal  |  0.05   |
|  751  |  lake  |  sal  |   0.1   |
|  752  |  lake  |  rad  |  2.19   |
|  752  |  lake  |  sal  |  0.09   |
|  752  |  lake  | temp  |  -16.0  |
|  752  |  roe   |  sal  |  41.6   |
|  837  |  lake  |  rad  |  1.46   |
|  837  |  lake  |  sal  |  0.21   |
|  837  |  roe   |  sal  |  22.5   |
|  844  |  roe   |  rad  |  11.25  |

`AND`와 `OR`을 결합할 수 있지만, 어떤 연산자가 먼저 실행되는지 주의해야 한다.
괄호를 사용하지 *않으면*, 다음과 같은 결과를 얻게 된다:

``` sql
SELECT * FROM Survey WHERE quant = 'sal' AND person = 'lake' OR person = 'roe';
```

| taken | person | quant | reading |
|:-----:|:------:|:-----:|:-------:|
|  734  |  lake  |  sal  |  0.05   |
|  751  |  lake  |  sal  |   0.1   |
|  752  |  lake  |  sal  |  0.09   |
|  752  |  roe   |  sal  |  41.6   |
|  837  |  lake  |  sal  |  0.21   |
|  837  |  roe   |  sal  |  22.5   |
|  844  |  roe   |  rad  |  11.25  |

이 쿼리는 Lake에 의한 염도(salinity) 측정과 Roerich에 의한 *모든* 측정을 포함한다.
대신에 아마도 다음과 같은 결과를 얻고자 했을 것이다.

``` sql
SELECT * FROM Survey WHERE quant = 'sal' AND (person = 'lake' OR person = 'roe');
```

| taken | person | quant | reading |
|:-----:|:------:|:-----:|:-------:|
|  734  |  lake  |  sal  |  0.05   |
|  751  |  lake  |  sal  |   0.1   |
|  752  |  lake  |  sal  |  0.09   |
|  752  |  roe   |  sal  |  41.6   |
|  837  |  lake  |  sal  |  0.21   |
|  837  |  roe   |  sal  |  22.5   |

## `LIKE` 키워드

SQL 필터링에서 `LIKE` 키워드의 중요성은 부분 일치를 통해 데이터를 필터링할 수 있게 해준다는 데에 있다.
예를 들어, 'DR'로 시작하는 사이트 이름과 같이 특정 패턴이나 문자열을 포함하는 레코드를 찾고 싶을 때 `LIKE` 키워드를 사용한다.
퍼센트 기호(%)는 **와일드카드**로서, 그 위치에 어떤 문자열이든 일치할 수 있게 한다.
이를 통해 문자열의 시작, 중간, 끝 부분에서 특정 패턴을 검색할 수 있다.
`LIKE`와 와일드카드의 조합은 SQL 쿼리에서 매우 유연한 문자열 검색을 가능하게 하며, 복잡하거나 정확하지 않은 데이터에서 원하는 정보를 효과적으로 추출하는 데 중요한 역할을 한다.

``` sql
SELECT * FROM Visited WHERE site LIKE 'DR%';
```

| id  | site |   dated    |
|:---:|:----:|:----------:|
| 619 | DR-1 | 1927-02-08 |
| 622 | DR-1 | 1927-02-10 |
| 734 | DR-3 | 1930-01-07 |
| 735 | DR-3 | 1930-01-12 |
| 751 | DR-3 | 1930-02-26 |
| 752 | DR-3 |            |
| 844 | DR-1 | 1932-03-22 |

마지막으로, `DISTINCT`를 `WHERE`와 함께 사용하여, 두 번째 수준 필터링 작업을 수행한다.

``` sql
SELECT DISTINCT person, quant FROM Survey WHERE person = 'lake' OR person = 'roe';
```

| person | quant |
|:------:|:-----:|
|  lake  |  sal  |
|  lake  |  rad  |
|  lake  | temp  |
|  roe   |  sal  |
|  roe   |  rad  |

하지만, 기억하라.
`DISTINCT`는 처리될 때 선택된 칼럼에 표시되는 값에만 적용되고 전체 행에는 적용되지 않는다.

::: callout-note
### 쿼리작성 방법

방금 수행한 방식이 대부분의 사람들이 SQL 쿼리를 "발전시키는" 방식이기도 하다.
의도한 것의 일부를 수행하는 단순한 것에서부터 시작했다.
그리고 절을 하나씩 하나씩 추가하면서 효과를 테스트했다.
좋은 전략이다.
사실 복잡한 쿼리를 작성할 때, 거의 *유일한* 전략이다.
하지만 이런 전략은 빠른 결과 확인과 더불어, 올바른 결과를 얻었을 때 빠른 인식에도 상당히 의존한다.

빠른 결과 확인을 이루는 가장 좋은 방법은 데이터의 일부를 임시 데이터베이스에 저장하고 그 위에서 쿼리를 실행하는 것이거나, 혹은 합리적으로 구성된 레코드로 소규모 데이터베이스를 채워두고 실험하는 것이다.
예를 들어, 실제 2000만 호주 인구의 데이터베이스에서 쿼리를 실행하기보다는 1만 명의 샘플을 추출하여 실험을 하거나, 무작위 또는 그럴듯한 1만 명의 레코드를 생성할 수 있는 작은 프로그램을 작성해 사용하는 것이다.
:::

## 연습문제 {.unnumbered}

### 쿼리 디버깅

극에서 48&deg보다 고위도에 위치한 모든 사이트를 선택하고자 한다고 가정하자.
작성한 첫번째 쿼리는 다음과 같다.

``` sql
SELECT * FROM Site WHERE (lat > -48) OR (lat < 48);
```

왜 이 쿼리가 잘못된 것인지 설명하세요.
그리고 쿼리를 다시 작성해서 올바르게 동작하게 만드세요.

------------------------------------------------------------------------

`OR`를 사용했기 때문에, 예를 들어 남극에 있는 사이트도 두 번째 기준을 만족하여 포함된다.
대신에, *두 가지 기준 모두*를 충족하는 사이트만을 포함시키고 싶다면 다음과 같이 쿼리를 수정한다.

``` sql
SELECT * FROM Site WHERE (lat > -48) AND (lat < 48);
```

작성된 쿼리는 위도가 -48보다 크고 48보다 작은 Site 테이블의 모든 레코드를 선택한다.
이는 사실상 남극과 북극 사이의 사이트들만을 대상으로 한다.

### 이상치 탐지

정규화된 염분 수치는 0.0에서 1.0 사이에 있어야 한다.
상기 범위 밖에 있는 염분수치를 가진 모든 레코드를 `Survey` 테이블에서 선택하는 쿼리를 작성하세요.

``` sql
SELECT * FROM Survey WHERE quant = 'sal' AND ((reading > 1.0) OR (reading < 0.0));
```

| taken | person | quant | reading |
|:-----:|:------:|:-----:|:-------:|
|  752  |  roe   |  sal  |  41.6   |
|  837  |  roe   |  sal  |  22.5   |

### 패턴 매칭

다음 표현식 중 참은 무엇인가?

1.  `'a' LIKE 'a'`
2.  `'a' LIKE '%a'`
3.  `'beta' LIKE '%a'`
4.  `'alpha' LIKE 'a%%'`
5.  `'alpha' LIKE 'a%p%'`

------------------------------------------------------------------------

표현식들이 참인 이유는 다음과 같습니다:

1.  `True` - 'a'와 'a'는 동일한 문자이기 때문이다.
2.  `True` - 와일드카드는 *제로* 또는 그 이상의 문자와 일치할 수 있기 때문이다.
3.  `True` - '%'가 'bet'과 일치하고, 'a'가 마지막 'a'와 일치한다.
4.  `True` - 첫 번째 와일드카드가 'lpha'와 일치하고, 두 번째 와일드카드는 제로 문자(또는 그 반대)와 일치한다.
5.  `True` - 첫 번째 와일드카드가 'l'과 일치하고, 두 번째 와일드카드가 'ha'와 일치한다.

만약 명명된 칼럼의 값이 주어진 패턴과 일치한다면 SQL 테스트 `*column-name* like *pattern*`은 참이다.
"0 혹은 그 이상의 문자와 매칭"된다는 것을 의미하기 위해서 '%'문자를 패턴에 임의 숫자 횟수에 사용한다.
반면, 표현식 `*column-name* not like *pattern*`은 매칭을 거꾸로 한다.
