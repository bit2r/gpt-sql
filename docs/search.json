[
  {
    "objectID": "sort-dup.html#정렬",
    "href": "sort-dup.html#정렬",
    "title": "4  정렬과 중복제거",
    "section": "4.1 정렬",
    "text": "4.1 정렬\n두 경우 모두에서, 중복된 값이 제거되었음을 알 수 있다. 데이터베이스 테이블에서 해당 행들이 인접해 있지 않아도 마찬가지다.\n다음 과제로 Person 테이블에서 탐사에 참여한 과학자들을 식별하는 것이다. 앞서 언급했듯이, 데이터베이스 레코드는 일반적으로 특정한 순서로 저장되지 않는다. 쿼리 결과가 반드시 정렬되어 있지 않으며, 설사 정렬되어 있다 해도, 원하는 다른 방식(예를 들어, 개인 이름 대신 식별자 등)으로 정렬 결과를 보고 싶을 때가 많다는 의미기도 하다. SQL에서는 쿼리에 ORDER BY 절을 추가함으로써 간단하게 구현할 수 있다.\nSELECT * FROM Person ORDER BY id;\n\n\n\nid\npersonal\nfamily\n\n\n\n\ndanfort\nFrank\nDanforth\n\n\ndyer\nWilliam\nDyer\n\n\nlake\nAnderson\nLake\n\n\npb\nFrank\nPabodie\n\n\nroe\nValentina\nRoerich\n\n\n\n기본설정으로 ORDER BY를 사용할 때, 결과는 지정한 칼럼 오름차순으로 정렬된다 (즉, 가장 작은 값에서 가장 큰 값으로).\nDESC(내림차순을 의미하는 “descending”의 약자)를 사용하여 반대 순서로 정렬할 수 있다.\n\n\n\n\n\n\n정렬 참고 사항\n\n\n\n데이터베이스에 쿼리문을 전송할 때마다 레코드가 일관되게 보이는 이유는 지금까지 아무도 데이터를 변경하거나 수정하지 않았기 때문이다. 행이 일관성을 갖고 예측 가능한 순서로 반환되기를 원한다면 ORDER BY를 사용하는 것을 기억하라.\n\n\n(오름차순 정렬을 명확히 하고 싶다면, DESC 대신 ASC를 사용한다.)\n각 사이트 방문 때 어떤 과학자가 양을 측정했는지 살펴보려면, 다시 Survey 테이블을 봐야 한다. 여러 칼럼을 한 번에 정렬할 수도 있다. 예를 들어, 다음 쿼리는 결과를 먼저 taken에 따라 오름차순으로 정렬한 다음, 각각의 동일한 taken 값 그룹 내에서 person에 따라 내림차순으로 정렬한다.\nSELECT taken, person, quant FROM Survey ORDER BY taken ASC, person DESC;\n\n\n\ntaken\nperson\nquant\n\n\n\n\n619\ndyer\nrad\n\n\n619\ndyer\nsal\n\n\n622\ndyer\nrad\n\n\n622\ndyer\nsal\n\n\n734\npb\nrad\n\n\n734\npb\ntemp\n\n\n734\nlake\nsal\n\n\n735\npb\nrad\n\n\n735\n-null-\nsal\n\n\n735\n-null-\ntemp\n\n\n751\npb\nrad\n\n\n751\npb\ntemp\n\n\n751\nlake\nsal\n\n\n752\nroe\nsal\n\n\n752\nlake\nrad\n\n\n752\nlake\nsal\n\n\n752\nlake\ntemp\n\n\n837\nroe\nsal\n\n\n837\nlake\nrad\n\n\n837\nlake\nsal\n\n\n844\nroe\nrad\n\n\n\n다음 쿼리를 통해 어떤 과학자가 방문에 관여했으며, 방문 동안 어떤 측정을 수행했는지를 잘 파악할 수 있다.\n테이블을 살펴보면, 일부 과학자들이 특정 종류의 측정에 전문화되어 있는 것처럼 보인다. 적절한 칼럼을 선택하고 중복을 제거함으로써 어떤 과학자가 어떤 측정을 수행했는지 선명히 드러난다.\nSELECT DISTINCT quant, person FROM Survey ORDER BY quant ASC;\n\n\n\nquant\nperson\n\n\n\n\nrad\ndyer\n\n\nrad\npb\n\n\nrad\nlake\n\n\nrad\nroe\n\n\nsal\ndyer\n\n\nsal\nlake\n\n\nsal\n-null-\n\n\nsal\nroe\n\n\ntemp\npb\n\n\ntemp\n-null-\n\n\ntemp\nlake\n\n\n\n데이터베이스 테이블의 레코드는 본질적으로 정렬되어 있지 않기 때문에, 특정 순서대로 표시하고 싶다면, ORDER BY를 명시적으로 사용하여 그 순서를 지정해야 한다. 데이터베이스 저장된 값은 고유함이 보장되지 않기 때문에, 중복을 제거하고 싶다면, DISTINCT를 사용하여 명시적으로 지정하여 처리해야만 된다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>정렬과 중복제거</span>"
    ]
  },
  {
    "objectID": "sort-dup.html#연습문제",
    "href": "sort-dup.html#연습문제",
    "title": "4  정렬과 중복제거",
    "section": "4.2 연습문제",
    "text": "4.2 연습문제\n\n4.2.1 중복 날짜\nVisited 테이블에서 별개로 구별되는 고유한(distinct) 날짜들을 선택하는 쿼리를 작성하시오.\n다음 쿼리는 Visited 테이블에서 중복 없이 모든 고유한 ‘dated’ 칼럼의 값을 반환한다.\nSELECT DISTINCT dated FROM Visited;\n\n\n\ndated\n\n\n\n\n1927-02-08\n\n\n1927-02-10\n\n\n1930-01-07\n\n\n1930-01-12\n\n\n1930-02-26\n\n\n \n\n\n1932-01-14\n\n\n1932-03-22\n\n\n\n\n\n4.2.2 조사자명\nPerson 테이블에 있는 과학자들 전체 이름을 표시하고, 가족 이름(family name)으로 정렬하는 쿼리문을 작성하시오.\n다음 쿼리는 Person 테이블에서 개인 이름(personal)과 가족 이름(family)을 결합하여 전체 이름(fullname)을 생성하고, 그 결과를 가족 이름으로 정렬해 반환한다. 여기서 ||는 문자열을 연결하는 SQL 연산자다.\nSELECT personal, family FROM Person ORDER BY family ASC;\n\n\n\npersonal\nfamily\n\n\n\n\nFrank\nDanforth\n\n\nWilliam\nDyer\n\n\nAnderson\nLake\n\n\nFrank\nPabodie\n\n\nValentina\nRoerich",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>정렬과 중복제거</span>"
    ]
  },
  {
    "objectID": "sort-dup.html#조사자명",
    "href": "sort-dup.html#조사자명",
    "title": "4  정렬과 중복제거",
    "section": "4.3 조사자명",
    "text": "4.3 조사자명\nPerson 테이블에 있는 과학자들 전체 이름을 표시하고, 가족 이름(family name)으로 정렬하는 쿼리문을 작성하시오.\n다음 쿼리는 Person 테이블에서 개인 이름(personal)과 가족 이름(family)을 결합하여 전체 이름(fullname)을 생성하고, 그 결과를 가족 이름으로 정렬해 반환한다. 여기서 ||는 문자열을 연결하는 SQL 연산자다.\nSELECT personal, family FROM Person ORDER BY family ASC;\n\n\n\npersonal\nfamily\n\n\n\n\nFrank\nDanforth\n\n\nWilliam\nDyer\n\n\nAnderson\nLake\n\n\nFrank\nPabodie\n\n\nValentina\nRoerich",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>정렬과 중복제거</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "들어가며",
    "section": "",
    "text": "엑셀로 대표되는 스프레드시트를 사용하는 것은 많은 사람들에게 익숙한 경험이다. 이들은 데이터를 쉽게 조작하고 분석할 수 있는 기본적인 도구로 활용되지만, 데이터셋이 복잡해지면서 한계에 부딪힌다. 이때 스프레드시트의 한계를 넘어서 데이터베이스의 역할이 중요해진다. 간단한 수치 연산에는 스프레드시트가 충분할 수 있지만, 복잡하고 큰 데이터셋을 빠르고 효율적으로 처리하려면 데이터베이스가 필요하다. SQL(Structured Query Language)은 데이터베이스를 관리하고 조작하는 데 있어 중요한 역할을 한다. 데이터베이스가 어떻게 작동하는지 이해하는 것은 단순한 데이터 조작 능력을 넘어서, 우리가 사용하는 다양한 시스템들이 왜 그런 방식으로 작동하는지, 그리고 왜 데이터를 특정한 방식으로 구조화하는지에 대한 깊은 이해를 제공한다.\n이 책은 데이터베이스의 기본 개념과 SQL을 다룬다. 데이터베이스의 기본 개념을 이해하고 SQL을 사용하는 방법을 익히면, 데이터베이스를 사용하는 다양한 시스템들을 쉽게 이해할 수 있다. 또한 데이터베이스를 사용하는 다양한 시스템들을 이해하면, 데이터베이스 기본 개념과 SQL을 더 깊게 이해할 수 있다.",
    "crumbs": [
      "들어가며"
    ]
  },
  {
    "objectID": "01-setup.html#sqlite-설치",
    "href": "01-setup.html#sqlite-설치",
    "title": "1  SQLite3",
    "section": "1.1 SQLite 설치",
    "text": "1.1 SQLite 설치\n명령-라인(command-line)을 통해 디렉토리를 이동하고 명령문을 실행하는 방법을 알고 있어야만 이후 학습내용을 빠르게 습득할 수 있다. 명령-라인, 콘솔, 쉘 등 주제가 낯설다면 챗GPT 유닉스 쉘(Unix Shell) 학습 자료를 확인해보길 권한다.\n데이터베이스와 SQL을 본격적으로 학습하기 전에, SQLite3를 설치해야 한다. SQLite3를 설치하는 방법은 운영 체제에 따라 차이가 난다.\n\n1.1.1 윈도우즈 SQLite3 설치\n\nSQLite 다운로드: SQLite 공식 웹사이트(https://www.sqlite.org/download.html)에서 Windows용 바이너리 파일을 다운로드한다.\n압축 해제: 다운로드한 파일을 압축 해제한다.\n시스템 환경 변수 설정: 압축 해제한 SQLite 실행 파일의 경로를 시스템 환경 변수에 추가하여 명령 프롬프트에서 어디서나 SQLite를 실행할 수 있도록 설정한다.\n\n\n\n1.1.2 맥OS SQLite3 설치\n맥OS에는 기본적으로 SQLite3가 설치되어 있지만, 최신 버전을 사용하고 싶다면, 다음 방법을 실행한다.\n\nHomebrew 설치: Homebrew가 설치되어 있지 않다면, 터미널에서 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 명령을 실행하여 설치한다.\nSQLite 설치: 터미널에서 brew install sqlite3 명령을 실행하여 SQLite를 설치한다.\n\n\n\n1.1.3 리눅스 SQLite3 설치\n리눅스 배포판 대부분에는 SQLite3가 이미 설치되어 있다. 만약 설치되어 있지 않거나 최신 버전을 설치하고 싶다면, 다음 방법을 사용하여 설치한다.\n\n패키지 관리자 설치: 리눅스 배포판 대부분에는 패키지 관지라를 제공하기 때문에, 우분투(Ubuntu)와 같은 데비안(Debian) 기반 시스템에서는 sudo apt-get install sqlite3 명령을 사용하고, 페도라(Fedora)와 같은 RPM 기반 시스템에서는 sudo yum install sqlite 명령으로 설치한다.\n\n\n\n1.1.4 설치 확인\n설치가 완료되면, 명령 프롬프트나 터미널에서 sqlite3 --version 명령을 실행하여 설치된 SQLite의 버전을 확인할 수 있다.\n$ sqlite3 --version\n3.40.1 2022-12-28 14:03:47 df5c253c0b3dd24916e4ec7cf77d3db5294cc9fd45ae7b9c5e82ad8197f38a24",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "01-setup.html#데이터베이스-설치",
    "href": "01-setup.html#데이터베이스-설치",
    "title": "1  SQLite3",
    "section": "1.2 데이터베이스 설치",
    "text": "1.2 데이터베이스 설치\nSQLite3를 설치했다면, 이제 데이터베이스(database)를 설치해야 한다. 데이터베이스는 테이블(table)과 뷰(view) 등의 객체가 포함된 파일이다. SQLite3는 데이터베이스를 생성할 때, 확장자를 지정하지 않는다. 데이터베이스 파일의 이름만 지정해도 되지만, 일반적으로 .db, .sqlite, .sqlite3 등 확장자를 사용하여 데이터베이스 파일임을 명확히 하는 것을 권장한다.\n\n1.2.1 survey.db 생성\n소프트웨어 카펜트리 “데이터베이스와 SQL” 학습 자료에서 사용할 데이터베이스 파일은 웹사이트(https://swcarpentry.github.io/sql-novice-survey/index.html)에서 다음과 같이 로컬 컴퓨터에 다운로드 받아 넣어두면 된다. 데이터베이스 파일 이름은 survey.db로 되어 있다.\n\n\n\nsurvey.db 다운로드\n\n\n또 다른 방법은 명령 프롬프트나 터미널에서 다음과 같이 직접 데이터베이스 파일을 생성하는 것이다.\n\n명령 라인 터미널 윈도우를 연다.\n다음과 같이 타이핑한다.\n\n$ mkdir ~/swc/sql\n\n생성한 디렉토리로 현재 작업 디렉토리를 변경한다.\n\n$ cd ~/swc/sql\n\nGitHub에서 “gen-survey-database.sql” 파일을 다운로드 한다.\n\n\n~/swc/sql 디렉토리로 이동한 후에 그 디렉토리에서 github 사이트 (https://github.com/swcarpentry/bc/blob/master/novice/sql/gen-survey-database.sql) 에 위치한 SQL 파일(“gen-survey-database.sql”)을 다운로드한다.\n파일이 GitHub 저장소 내에 위치하고 있어서, 전체 Git 저장소(git repo)를 복제(cloning)하지 않고 단일 파일만 로컬로 가져온다.\n이 목적을 달성하기 위해서, HTTP, HTTPS, FTP 프로토콜을 지원하는 명령-라인 웹크롤러(web-crawler) 소프트웨어 GNU Wget 혹은, 다양한 프로토콜을 사용하여 데이터를 전송하는데 사용되는 라이브러리이며 명령-라인 도구인 cURL을 사용한다. 두가지 도구 모두 크로스 플랫폼(cross platform)으로 다양한 운영체제를 지원한다.\n\nWget 혹은 cURL을 로컬에 설치한 후에, 터미널에서 다음 명령어를 실행한다.\n\n만약 cURL을 선호한다면, 다음 명령문에서 “wget”을 “curl -O”로 대체한다.\n\n$ wget https://raw.githubusercontent.com/swcarpentry/bc/master/novice/sql/gen-survey-database.sql\n상기 명령문으로 Wget은 HTTP 요청을 생성해서 github 저장소의 “gen-survey-database.sql” 파일만 현재 작업 디렉토리로 가져온다. 성공적으로 완료되면 터미널은 다음 출력결과를 화면에 표시한다.\n\n--2024-01-01 11:49:13--  https://raw.githubusercontent.com/swcarpentry/bc/master/novice/sql/gen-survey-database.sql\n\nLoaded CA certificate '/usr/ssl/certs/ca-bundle.crt'\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.110.133, 185.199.109.133, 185.199.108.133, ...\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.110.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 3297 (3.2K) [text/plain]\nSaving to: ‘gen-survey-database.sql’\n\n     0K ...                                                   100% 4.15M=0.001s\n\n2024-01-01 11:49:13 (4.15 MB/s) - ‘gen-survey-database.sql’ saved [3297/3297]\nsqlite3 survey.db &lt; gen-survey-database.sql 명령어는 SQLite3 데이터베이스 엔진을 사용하여 survey.db라는 데이터베이스 파일에 gen-survey-database.sql 파일에 포함된 SQL 명령들을 실행한다. 참고로, gen-survey-database.sql 파일에는 데이터베이스 구조를 정의하고 데이터를 삽입하는 SQL 명령들을 포함하고 있다. 예를 들어, Person 테이블 에는 ‘ident’, ‘personal’, ‘family’라는 세 개의 열이 정의되어 있고, 여러 사람의 정보를 테이블에 삽입하는 명령이 포함되어 있으며, ’dyer’, ‘William’, ’Dyer’와 같은 사람이 각각의 열에 맞추어 삽입된다.\n$ sqlite3 survey.db &lt; gen-survey-database.sql",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "01-setup.html#sqlite-db-연결",
    "href": "01-setup.html#sqlite-db-연결",
    "title": "1  SQLite3",
    "section": "1.3 SQLite DB 연결",
    "text": "1.3 SQLite DB 연결\n생성된 데이터베이스에 연결하기 위해서, 데이터베이스를 생성한 디렉토리 안에서 SQLite를 시작한다. 그래서 ~/swc/sql 디렉토리에서 다음과 같이 타이핑한다.\n$ sqlite3 survey.db\n“sqlite3 survey.db” 명령문이 데이터베이스를 열고 데이터베이스 명령-라인 프롬프트로 안내한다. SQLite에서 데이터베이스는 플랫 파일(flat file)로 명시적으로 열 필요가 있다. 그리고 나서 SQLite 시작되고 “sqlite”로 명령-라인 프롬프트로 다음과 같이 변경되어 표시된다.\n$ sqlite3 survey.db \nSQLite version 3.34.1 2021-01-20 14:10:07\nEnter \".help\" for usage hints.\nsqlite&gt;\n다음 출력결과가 보여주듯이 .databases 명령문으로 소속된 데이터베이스 이름과 파일 목록을 확인한다.\nsqlite&gt; .databases\nseq  name             file                                                      \n---  ---------------  ----------------------------------------------------------\n0    main             ~/swc/sql/survey.db &lt;/code&gt;&lt;/pre&gt;\n다음과 같이 타이핑해서 필요한 “Person”, “Survey”, “Site” “Visited” 테이블이 존재하는 것을 확인한다.\nsqlite&gt; .tables\n그리고 “.table”의 출력결과는 다음과 같다.\nsqlite&gt; .tables\nPerson   Site     Survey   Visited\n이제, 설치를 완료해서 다음 학습으로 진행할 수 있다. 현재 명령-라인 SQLite 세션에서 다음 연습을 수행할 수 있다.\n\n1.3.1 SQLite3 빠져 나오기\nSQLite3를 빠져나오기 위해서, 다음과 같이 타이핑한다.\nsqlite&gt; .quit\n\n\n\n\n\n\nSQLite3 CLI 대신 IPython notebook 사용방법\n\n\n\n만약 실습으로 IPython notebook 사용을 선호한다면, IPython이 로컬 컴퓨터에 설치되었는지 점검하라. 만약 설치되어 있지 않다면, 설치 방법을 참고하여 설치한다. 만약 IPython이 이미 로컬 컴퓨터에 설치되어 있다면 notebook을 열기 위해서 작업 폴더 ~/swc/sql으로 이동해서 “ipython notebook”을 타이핑한다.\n$ ipython notebook\n상기 명령어가 IPython 커널을 구동해서 디폴트 브라우져에 인터랙티브 노트북을 화면에 표시해서 편집할 수 있게 된다. 작업이 종료되면 변경사항을 간직하기 위해 노트북 저장을 기억하다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>SQLite3</span>"
    ]
  },
  {
    "objectID": "02-database.html#r-db-what-it-is",
    "href": "02-database.html#r-db-what-it-is",
    "title": "2  데이터베이스와 SQL",
    "section": "2.1 데이터베이스가 뭔가요?",
    "text": "2.1 데이터베이스가 뭔가요?\n데이터베이스(database)는 데이터를 저장하기 위한 목적으로 조직된 파일이다. 대부분의 데이터베이스는 키(key)와 값(value)를 매핑한다는 의미에서 딕셔너리처럼 조직되었다. 가장 큰 차이점은 데이터베이스는 디스크(혹은 다른 영구 저장소)에 위치하고 있어서, 프로그램 종료 후에도 정보가 계속 저장된다. 데이터베이스가 영구 저장소에 저장되어서, 컴퓨터 주기억장치(memory) 크기에 제한받는 딕셔너리보다 훨씬 더 많은 정보를 저장할 수 있다.\n딕셔너리처럼, 데이터베이스 소프트웨어는 엄청난 양의 데이터 조차도 매우 빠르게 삽입하고 접근하도록 설계되었다. 컴퓨터가 특정 항목으로 빠르게 찾아갈 수 있도록 데이터베이스에 인덱스(indexes)를 추가한다. 데이터베이스 소프트웨어는 인덱스를 구축하여 성능을 보장한다.\n다양한 목적에 맞춰 서로 다른 많은 데이터베이스 시스템이 개발되어 사용되고 있다. Oracle, MySQL, Microsoft SQL Server, PostgreSQL, SQLite이 여기에 포함된다. 이 책에서는 SQLite를 집중해서 살펴볼 것이다. 왜냐하면 매우 일반적인 데이터베이스이며 파이썬에 이미 내장되어 있기 때문이다. 응용프로그램 내부에서 데이터베이스 기능을 제공하도록 SQLite가 다른 응용프로그램 내부에 내장(embedded)되도록 설계되었다. 예를 들어, 다른 많은 소프트웨어 제품이 그렇듯이, 파이어폭스 브라우져도 SQLite를 사용한다.\n\nhttp://sqlite.org/\n\n이번 장에서 기술하는 트위터 스파이더링 응용프로그램처럼 정보과학(Informatics)에서 마주치는 몇몇 데이터 조작 문제에 SQLite가 적합하다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#r-db-concept",
    "href": "02-database.html#r-db-concept",
    "title": "2  데이터베이스와 SQL",
    "section": "2.2 데이터베이스 개념",
    "text": "2.2 데이터베이스 개념\n처음 데이터베이스를 볼때 드는 생각은 마치 엑셀같은 다중 시트를 지닌 스프레드쉬트(spreadsheet)같다는 것이다. 데이터베이스에서 주요 데이터 구조물은 테이블(tables), 행(rows), and 열(columns)이 된다.\n\n\n\n데이터베이스 개념\n\n\n관계형 데이터베이스의 기술적인 면을 설명하면 테이블, 행, 열의 개념은 관계(relation), 튜플(tuple), 속성(attribute) 각각 형식적으로 매칭된다. 이번 장에서는 조금 덜 형식 용어를 사용한다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#r-db-firefox",
    "href": "02-database.html#r-db-firefox",
    "title": "2  데이터베이스와 SQL",
    "section": "2.3 파이어폭스 SQLite 관리자",
    "text": "2.3 파이어폭스 SQLite 관리자\nSQLite 데이터베이스 파일에 있는 데이터를 다루기 위해서 이번장에서 주로 R 사용에 집중을 하지만, 다음 웹사이트에서 무료로 이용 가능한 SQLite 데이터베이스 매니저(SQLite Database Manager)로 불리는 파이어폭스 애드온(add-on)을 사용해서 좀더 쉽게 많은 작업을 수행할 수 있다. 파이어폭스 애드온은 크롬 확장 프로그램과 유사한 개념으로 파이어폭스는 개발자들이 많이 사용하는 웹브라우져 중 하나다.\n\nhttps://addons.mozilla.org/en-us/firefox/addon/sqlite-manager/\n\n브라우져를 사용해서 쉽게 테이블을 생성하고, 데이터를 삽입, 편집하고 데이터베이스 데이터에 대해 간단한 SQL 질의를 실행할 수 있다.\n이러한 점에서 데이터베이스 매니저는 텍스트 파일을 작업할 때 사용하는 텍스트 편집기와 유사하다. 텍스트 파일에 하나 혹은 몇개 작업만 수행하고자 하면, 텍스트 편집기에서 파일을 열어 필요한 수정작업을 하고 닫으면 된다. 텍스트 파일에 작업할 사항이 많은 경우는 종종 간단한 R 프로그램을 작성하여 수행한다. 데이터베이스로 작업할 때도 동일한 패턴이 발견된다. 간단한 작업은 데이터베이스 매니저를 통해서 수행하고, 좀더 복잡한 작업은 R로 수행하는 것이 더 편리하다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#r-db-create-table",
    "href": "02-database.html#r-db-create-table",
    "title": "2  데이터베이스와 SQL",
    "section": "2.4 데이터베이스 테이블 생성",
    "text": "2.4 데이터베이스 테이블 생성\n데이터베이스는 R 리스트 혹은 딕셔너리보다 좀더 명확히 정의된 구조를 요구한다. 1\n데이터베이스에 테이블(table)을 생성할 때, 열(column)의 명칭과 각 열(column)에 저장하는 테이터 형식을 사전에 정의해야 한다. 데이터베이스 소프트웨어가 각 열의 데이터 형식을 인식하게 되면, 데이터 형식에 따라 데이터를 저장하고 찾아오는 방법을 가장 효율적인 방식을 선택할 수 있다.\n다음 url에서 SQLite에서 지원되는 다양한 데이터 형식을 살펴볼 수 있다.\n\nhttp://www.sqlite.org/datatypes.html\n\n처음에는 데이터 구조를 사전에 정의하는 것이 불편하게 보이지만, 대용량의 데이터가 데이터베이스에 포함되더라도 데이터의 빠른 접근을 보장하는 잇점이 있다.\n데이터베이스 파일과 데이터베이스에 두개의 열을 가진 Tracks 이름의 테이블을 생성하는 코드는 다음과 같다.\n\nlibrary(RSQLite)\n\nmusic_db  &lt;- \"data/music.sqlite\"\nconn &lt;- dbConnect(drv = SQLite(), dbname= music_db)\n\ndbSendQuery(conn, \"INSERT INTO Tracks (title, plays) VALUES ( ?, ? )\", c('Thunderstruck', 20))\ndbSendQuery(conn, \"INSERT INTO Tracks (title, plays) VALUES ( ?, ? )\", c('My Way', 15))\n\ndbDisconnect(conn)\n\n연결 (connect) 연산은 현재 디렉토리 data/music.sqlite3 파일에 저장된 데이터베이스에 “연결(connection)”한다. 파일이 존재하지 않으면, 자동 생성된다. “연결(connection)”이라고 부르는 이유는 때때로 데이터베이스가 응용프로그램이 실행되는 서버로부터 분리된 “데이터베이스 서버(database server)”에 저장되기 때문이다. 지금 간단한 예제 파일의 경우에 데이터베이스가 로컬 파일 형태로 R 코드 마찬가지로 동일한 디렉토리에 있다.\n파일을 다루는 파일 핸들(file handle)처럼 데이터베이스에 저장된 파일에 연산을 수행하기 위해서 커서(cursor)를 사용한다. cursor()를 호출하는 것은 개념적으로 텍스트 파일을 다룰 때 readLines()을 호출하는 것과 개념적으로 매우 유사하다.\n\n\n\n데이터베이스 커서\n\n\n커서가 생성되면, dbGetQuery() 함수를 사용하여 데이터베이스 콘텐츠에 명령어 실행을 할 수 있다.\n데이터베이스 명령어는 특별한 언어로 표현된다. 단일 데이터베이스 언어를 학습하도록 서로 다른 많은 데이터베이스 업체 사이에서 표준화되었다.\n데이터베이스 언어를 SQL(Structured Query Language 구조적 질의 언어)로 부른다.\n\nhttp://en.wikipedia.org/wiki/SQL\n\n상기 예제에서, 데이터베이스에 두개의 SQL 명령어를 실행했다. 관습적으로 데이터베이스 키워드는 대문자로 표기한다. 테이블명이나 열의 명칭처럼 사용자가 추가한 명령어 부분은 소문자로 표기한다.\n첫 SQL 명령어는 만약 존재한다면 데이터베이스에서 Tracks 테이블을 삭제한다. 동일한 프로그램을 실행해서 오류 없이 반복적으로 Tracks 테이블을 생성하도록하는 패턴이다. DROP TABLE 명령어는 데이터베이스 테이블 및 테이블 콘텐츠 전부를 삭제하니 주의한다. (즉, “실행취소(undo)”가 없다.)\n`dbGetQuery(conn, 'DROP TABLE IF EXISTS Tracks ') `\n두번째 명령어는 title 문자형 열과 plays 정수형 열을 가진 Tracks으로 명명된 테이블을 생성한다.\n`dbGetQuery(conn, 'CREATE TABLE Tracks (title TEXT, plays INTEGER)')`\n이제 Tracks으로 명명된 테이블을 생성했으니, SQL INSERT 연산을 통해 테이블에 데이터를 넣을 수 있다. 다시 한번, 데이터베이스에 연결하여 커서(cursor)를 얻어 작업을 시작한다. 그리고 나서 커서를 사용해서 SQL 명령어를 수행한다.\nSQL INSERT 명령어는 어느 테이블을 사용할지 특정한다. 그리고 나서 (title, plays) 포함할 필드 목록과 테이블 새로운 행에 저장될 VALUES 나열해서 신규 행을 정의를 마친다. 실제 값이 execute() 호출의 두번째 매개변수로 튜플 ('My Way', 15) 로 넘겨는 것을 표기하기 위해서 값을 물음표 (?, ?)로 명기한다.\n\nlibrary(RSQLite)\n\nmusic_db  &lt;- \"data/music.sqlite\"\nconn &lt;- dbConnect(drv = SQLite(), dbname= music_db)\n\ndbSendQuery(conn, \"INSERT INTO Tracks (title, plays) VALUES ( ?, ? )\", \n            c('Thunderstruck', 20))\ndbSendQuery(conn, \"INSERT INTO Tracks (title, plays) VALUES ( ?, ? )\", \n            c('My Way', 15))\n\nprint('Tracks:')\n\ndbGetQuery(conn, 'SELECT title, plays FROM Tracks')\n\ndbSendQuery(conn, \"DELETE FROM Tracks WHERE plays &lt; 100\")\n\ndbDisconnect(conn)\n\n먼저 테이블에 두개 열을 삽입(INSERT)하여 데이터를 데이터베이스에 저장되도록 했다. 그리고 나서, SELECT 명령어를 사용하여 테이블에 방금 전에 삽입한 행을 불러왔다. SELECT 명령어에서 데이터를 어느 열(title, plays)에서, 어느 테이블Tracks에서 가져올지 명세한다. 프로그램 실행결과는 다음과 같다.\n\n&gt; dbGetQuery(conn, 'SELECT title, plays FROM Tracks')\n          title plays\n1 Thunderstruck    20\n2        My Way    15\n\n프로그램 마지막에 SQL 명령어를 실행 사용해서 방금전에 생성한 행을 모두 삭제(DELETE)했기 때문에 프로그램을 반복해서 실행할 수 있다. 삭제(DELETE) 명령어는 WHERE 문을 사용하여 선택 조건을 표현할 수 있다. 따라서 명령문에 조건을 충족하는 행에만 명령문을 적용한다. 이번 예제에서 기준이 모든 행에 적용되어 테이블에 아무 것도 없게 된다. 따라서 프로그램을 반복적으로 실행할 수 있다. 삭제(DELETE)를 실행한 후에 데이터베이스에서 데이터를 완전히 제거했다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#r-db-sql",
    "href": "02-database.html#r-db-sql",
    "title": "2  데이터베이스와 SQL",
    "section": "2.5 SQL 요약",
    "text": "2.5 SQL 요약\n지금까지, R 예제를 통해서 SQL(Structured Query Language)을 사용했고, SQL 명령어에 대한 기본을 다루었다. 이번 장에서는 SQL 언어를 보고 SQL 구문 개요를 살펴본다.\n대단히 많은 데이터베이스 업체가 존재하기 때문에 호환성의 문제로 SQL(Structured Query Language)이 표준화되었다. 그래서, 여러 업체가 개발한 데이터베이스 시스템 사이에 호환하는 방식으로 커뮤니케이션 가능하다.\n관계형 데이터베이스는 테이블, 행과 열로 구성된다. 열(column)은 일반적으로 텍스트, 숫자, 혹은 날짜 자료형을 갖는다. 테이블을 생성할 때, 열의 명칭과 자료형을 지정한다.\nCREATE TABLE Tracks (title TEXT, plays INTEGER)\n테이블에 행을 삽입하기 위해서 SQL INSERT 명령어를 사용한다.\nINSERT INTO Tracks (title, plays) VALUES ('My Way', 15)\nINSERT 문장은 테이블 이름을 명기한다. 그리고 나서 새로운 행에 놓고자 하는 열/필드 리스트를 명시한다. 그리고 나서 키워드 VALUES와 각 필드 별로 해당하는 값을 넣는다.\nSQL SELECT 명령어는 데이터베이스에서 행과 열을 가져오기 위해 사용된다. SELECT 명령문은 가져오고자 하는 행과 WHERE절을 사용하여 어느 행을 가져올지 지정한다. 선택 사항으로 ORDER BY 절을 이용하여 반환되는 행을 정렬할 수도 있다.\nSELECT * FROM Tracks WHERE title = 'My Way'\n* 을 사용하여 WHERE 절에 매칭되는 각 행의 모든 열을 데이터베이스에서 가져온다.\n주목할 점은 R과 달리 SQL WHERE 절은 등식을 시험하기 위해서 두개의 등치 기호 대신에 단일 등치 기호를 사용한다. WHERE에서 인정되는 다른 논리 연산자는 &lt;,&gt;,&lt;=,&gt;=,!= 이고, 논리 표현식을 생성하는데 AND, OR, 괄호를 사용한다.\n다음과 같이 반환되는 행이 필드값 중 하나에 따라 정렬할 수도 있다.\nSELECT title,plays FROM Tracks ORDER BY title\n행을 제거하기 위해서, SQL DELETE 문장에 WHERE 절이 필요하다. WHERE 절이 어느 행을 삭제할지 결정한다.\nSELECT title,plays FROM Tracks ORDER BY title\n다음과 같이 SQL UPDATE 문장을 사용해서 테이블에 하나 이상의 행 내에 있는 하나 이상의 열을 갱신(UPDATE)할 수 있다.\nUPDATE Tracks SET plays = 16 WHERE title = 'My Way'\nUPDATE 문장은 먼저 테이블을 명시한다. 그리고 나서, SET 키워드 다음에 변경할 필드 리스트 와 값을 명시한다. 그리고 선택사항으로 갱신될 행을 WHERE절에 지정한다. 단일 UPDATE 문장은 WHERE절에서 매칭되는 모든 행을 갱신한다. 혹은 만약 WHERE절이 지정되지 않으면,테이블 모든 행에 대해서 갱신(UPDATE)을 한다.\n네가지 기본 SQL 명령문(INSERT, SELECT, UPDATE, DELETE)은 데이터를 생성하고 유지 관리하는데 필요한 기본적인 4가지 작업을 가능케 한다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#r-datamodeling-basics",
    "href": "02-database.html#r-datamodeling-basics",
    "title": "2  데이터베이스와 SQL",
    "section": "2.6 데이터 모델링 기초",
    "text": "2.6 데이터 모델링 기초\n관계형 데이터베이스의 진정한 힘은 다중 테이블과 테이블 사이의 관계를 생성할 때 생긴다. 응용프로그램 데이터를 쪼개서 다중 테이블과 두 테이블 간에 관계를 설정하는 것을 데이터 모델링(data modeling)이라고 한다. 테이블 정보와 테이블 관계를 표현하는 설계 문서를 데이터 모델(data model)이라고 한다.\n데이터 모델링(data modeling)은 상대적으로 고급 기술이여서 이번 장에서는 관계형 데이터 모델링의 가장 기본적인 개념만을 소개한다. 데이터 모델링에 대한 좀더 자세한 사항은 다음 링크에서 시작해 볼 수 있다.\n\nhttp://en.wikipedia.org/wiki/Relational_model\n\n트위터 스파이더 응용프로그램으로 단순히 한 사람의 친구가 몇명인지 세는 대신에, 모든 관계 리스트를 가지고서 특정 계정에 팔로잉하는 모든 사람을 찾는다.\n모두 팔로잉하는 계정을 많이 가지고 있어서, 트위터(Twitter) 테이블에 단순히 하나의 열만을 추가해서는 해결할 수 없다. 그래서 친구를 짝으로 추적할 수 있는 새로운 테이블을 생성한다. 다음이 간단하게 상기 테이블을 생성하는 방식이다.\n    CREATE TABLE Pals (from_friend TEXT, to_friend TEXT)\ndrchuck을 팔로잉하는 사람을 마주칠 때마다, 다음과 같은 형식의 행을 삽입한다.\n    INSERT INTO Pals (from_friend,to_friend) VALUES ('drchuck', 'lhawthorn')\ndrchuck 트위터 피드에서 친구 20명을 처리하면서, “drchuck”을 첫 매개변수로 가지는 20개 레코드를 삽입해서 데이터베이스에 중복되는 많은 문자열이 생길 것이다.\n문자열 데이터 중복은 데이터베이스 정규화(database normalization) 모범 사례(berst practice)를 위반하게 만든다. 기본적으로 데이터베이스 정규화는 데이터베이스에 결코 한번 이상 동일한 문자열을 저장하지 않는다. 만약 한번 이상 데이터가 필요하다면, 그 특정 데이터에 대한 숫자 키(key)를 생성하고, 그 키를 사용하여 실제 데이터를 참조한다.\n실무에서, 문자열이 컴퓨터 주기억장치나 디스크에 저장되는 정수형 자료보다 훨씬 많은 공간을 차지하고 더 많은 처리시간이 비교나 정렬에 소요된다. 항목이 단지 수백개라면, 저장소나 처리 시간이 그다지 문제되지 않는다. 하지만, 데이터베이스에 수백만명의 사람 정보와 1억건 이상의 링크가 있다면, 가능한 빨리 데이터를 스캔하는 것이 정말 중요하다.\n앞선 예제에서 사용된 Twitter 테이블 대신에 People로 명명된 테이블에 트위커 계정을 저장한다. People 테이블은 트위터 사용자에 대한 행과 관련된 숫자키를 저장하는 추가 열(column)이 있다. SQLite는 데이터 열의 특별한 자료형(INTEGER PRIMARY KEY)을 이용하여 테이블에 삽입할 임의 행에 대해서 자동적으로 키값을 추가하는 기능이 있다.\n다음과 같이 추가적인 id 열을 가진 People 테이블을 생성할 수 있다.\n    CREATE TABLE People \n        (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)\nPeople 테이블의 각 행에서 친구 숫자를 더 이상 유지관리하고 있지 않음을 주목하세요. id 열 자료형으로 INTEGER PRIMARY KEY 선택할 때 함축되는 의미는 다음과 같다., 사용자가 삽입하는 각 행에 대해서 SQLite가 자동으로 유일한 숫자 키를 할당하고 관리하게 한다. UNIQUE 키워드를 추가해서 SQLite에 name에 동일한 값을 가진 두 행을 삽입하지 못하게 한다.\n상기 Pals 테이블을 생성하는 대신에, 데이터베이스에 from_id, to_id 두 정수 자료형 열을 지닌 Follows 테이블을 생성한다. Follows 테이블은 from_id과 to_id의 조합으로 테이블이 유일하다는 제약사항도 가진다. (즉, 중복된 행을 삽입할 수 없다.)\n    CREATE TABLE Follows \n        (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id) )\n테이블에 UNIQUE절을 추가한다는 의미는 레코드를 삽입할 때 데이터베이스에서 지켜야하는 규칙 집합을 의사소통하는 것이다. 잠시 후에 보겠지만, 프로그램상에 편리하게 이러한 규칙을 생성한다. 이러한 규칙 집합은 실수를 방지하게 하고 코드를 작성을 간결하게 한다.\n본질적으로 Follows 테이블을 생성할 때, “관계(relationship)”를 모델링하여 한 사람이 다른 사람을 “팔로우(follow)”하고 이것을 (a) 사람이 연결되어 있고, (b) 관계을 방향성이 나타나도록 숫자를 짝지어 표현한다.\n\n\n\n트위터 관계 데이터베이스 모델링\n\n\n\n2.6.1 테이블 제약사항\n테이블 구조를 설계할 때, 데이터베이스 시스템에 몇 가지 규칙을 설정할 수 있다. 이러한 규칙은 실수를 방지하고 잘못된 데이터가 테이블에 들어가는 것을 막는다. 테이블을 생성할 때:\ndbSendQuery( conn, 'CREATE TABLE IF NOT EXISTS People (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)\")\n\ndbSendQuery( conn, 'CREATE TABLE IF NOT EXISTS Follows (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id))')\nPeople 테이블에 name 칼럼이 유일(UNIQUE)함을 나타낸다. Follows 테이블의 각 행에서 두 숫자 조합은 유일하다는 것도 나타낸다. 하나 이상의 동일한 관계를 추가하는 것 같은 실수를 이러한 제약 사항을 통해서 방지한다.\n다음 코드에서 이런 제약사항의 장점을 확인할 수 있다.\ndbSendQuery( conn, 'INSERT OR IGNORE INTO People (name, retrieved) VALUES ( ?, 0)', c( 'friend', ) )\nINSERT 문에 OR IGNORE 절을 추가해서 만약 특정 INSERT가 “name이 유일(unique)해야 한다”를 위반하게 되면, 데이터베이스 시스템은 INSERT를 무시한다. 데이터베이스 제약 사항을 안전망으로 사용해서 무언가가 우연히 잘못되지 않게 방지한다.\n마찬가지로, 다음 코드는 정확히 동일 Follows관계를 두번 추가하지 않는다.\ndbSendQuery( conn, 'INSERT OR IGNORE INTO Follows (from_id, to_id) VALUES (?, ?)', c(id, friend_id) )\n다시 한번, Follows 행에 대해 지정한 유일한 제약사항을 위반하게 되면 INSERT 시도를 무시하도록 데이터베이스에 지시한다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#db-three-keys",
    "href": "02-database.html#db-three-keys",
    "title": "2  데이터베이스와 SQL",
    "section": "2.7 세 종류 키",
    "text": "2.7 세 종류 키\n지금까지 데이터를 다중 연결된 테이블에 넣고 키(keys)를 사용하여 행을 연결하는 방식으로 데이터 모델을 생성했는데, 키와 관련된 몇몇 용어를 살펴볼 필요가 있다. 일반적으로 데이터베이스 모델에서 세가지 종류의 키가 사용된다.\n\n논리 키(logical key)는 “실제 세상”이 행을 찾기 위해서 사용하는 키다. 데이터 모델 예제에서, name 필드는 논리키다. 사용자에 대해서 screen_name이고, name 필드를 사용하여 프로그램에서 여러번 사용자 행을 찾을 수 있다. 논리 키에 UNIQUE 제약 사항을 추가하는 것이 의미있다는 것을 종종 이해하게 된다. 논리 키는 어떻게 바깥 세상에서 행을 찾는지 다루기 때문에, 테이블에 동일한 값을 가진 다중 행이 존재한다는 것은 의미가 없다.\n주키(primary key)는 통상적으로 데이터베이스에서 자동 대입되는 숫자다. 프로그램 밖에서는 일반적으로 의미가 없고, 단지 서로 다른 테이블에서 행을 열결할 때만 사용된다. 테이블에 행을 찾을 때, 통상적으로 주키를 사용해서 행을 찾는 것이 가장 빠르게 행을 찾는 방법이다. 주키는 정수형이어서, 매우 적은 저장공간을 차지하고 매우 빨리 비교 혹은 정렬할 수 있다. 이번에 사용된 데이터 모델에서 id 필드가 주키의 한 예가 된다.\n외부 키(foreign key)는 일반적으로 다른 테이블에 연관된 행의 주키를 가리키는 숫자다. 이번에 사용된 데이터 모델의 외부 키의 사례는 from_id다.\n\n주키 id필드명을 호출하고, 항상 외부키에 임의 필드명에 접미사로 _id 붙이는 명명규칙을 사용한다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#db-debugging",
    "href": "02-database.html#db-debugging",
    "title": "2  데이터베이스와 SQL",
    "section": "2.8 디버깅",
    "text": "2.8 디버깅\nSQLite 데이터베이스에 연결하는 파이썬 프로그램을 개발할 때 하나의 일반적인 패턴은 파이썬 프로그램을 실행하고 SQLite 데이터베이스 브라우저를 통해서 결과를 확인하는 것이다. 브라우저를 통해서 빠르게 프로그램이 정상적으로 작동하는지를 확인할 수 있다.\nSQLite에서 두 프로그램이 동시에 동일한 데이터를 변경하지 못하기 때문에 주의가 필요하다. 예를 들어, 브라우저에서 데이터베이스를 열고 데이터베이스에 변경을 하고 “저장(save)”버튼을 누르지 않는다면, 브라우져는 데이터베이스 파일에 “락(lock)”을 걸구, 다른 프로그램이 파일에 접근하는 것을 막는다. 특히, 파일이 잠겨져 있으면 작성하고 있는 파이썬 프로그램이 파일에 접근할 수 없다.\n해결책은 데이터베이스가 잠겨져 있어서 파이썬 코드가 작동하지 않는 문제를 피하도록 파이썬에서 데이터베이스에 접근하려 시도하기 전에 데이터베이스 브라우져를 닫거나 혹은 File 메뉴를 사용해서 브라우져 데이터베이스를 닫는 것이다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "02-database.html#db-terminology",
    "href": "02-database.html#db-terminology",
    "title": "2  데이터베이스와 SQL",
    "section": "2.9 용어정의",
    "text": "2.9 용어정의\n\n속성(attribute): 튜플 내부에 값의 하나. 좀더 일반적으로 “열”, “칼럼”, “필드”로 불린다.\n제약(constraint): 데이터베이스가 테이블의 필드나 행에 규칙을 강제하는 것. 일반적인 제약은 특정 필드에 중복된 값이 없도록 하는 것(즉, 모든 값이 유일해야 한다.)\n커서(cursor): 커서를 사용해서 데이터베이스에서 SQL 명령어를 수행하고 데이터베이스에서 데이터를 가져온다. 커서는 네트워크 연결을 위한 소켓이나 파일의 파일 핸들러와 유사하다.\n데이터베이스 브라우져(database browser): 프로그램을 작성하지 않고 직접적으로 데이터베이스에 연결하거나 데이터베이스를 조작할 수 있는 소프트웨어.\n외부 키(foreign key): 다른 테이블에 있는 행의 주키를 가리키는 숫자 키. 외부 키는 다른 테이블에 저장된 행사이에 관계를 설정한다.\n인텍스(index): 테이블에 행이 추가될 때 정보 검색하는 것을 빠르게 하기 위해서 데이터베이스 소프트웨어가 유지관리하는 추가 데이터.\n논리 키(logical key): “외부 세계”가 특정 행의 정보를 찾기 위해서 사용하는 키. 사용자 계정 테이블의 예로, 사람의 전자우편 주소는 사용자 데이터에 대한 논리 키의 좋은 후보자가 될 수 있다.\n정규화(normalization): 어떠한 데이터도 중복이 없도록 데이터 모델을 설계하는 것. 데이터베이스 한 장소에 데이터 각 항목 정보를 저장하고 외부키를 이용하여 다른 곳에서 참조한다.\n주키(primary key): 다른 테이블에서 테이블의 한 행을 참조하기 위해서 각 행에 대입되는 숫자 키. 종종 데이터베이스는 행이 삽입될 때 주키를 자동 삽입하도록 설정되었다.\n관계(relation): 튜플과 속성을 담고 있는 데이터베이스 내부 영역. 좀더 일반적으로 “테이블(table)”이라고 한다.\n튜플(tuple):데이터베이스 테이블에 단일 항목으로 속성 집합이다. 좀더 일반적으로 “행(row)”이라고 한다.",
    "crumbs": [
      "환경설정",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>데이터베이스와 SQL</span>"
    ]
  },
  {
    "objectID": "select.html#기본-지식",
    "href": "select.html#기본-지식",
    "title": "3  데이터 선택하기",
    "section": "3.1 기본 지식",
    "text": "3.1 기본 지식\n관계형 데이터베이스(relational database)는 테이블(tables)로 정렬된 정보를 저장하고 다루는 방식이다. 각 테이블은 데이터를 기술하는 필드(fields)로도 알려진 열(column)과 데이터를 담고 있는 레코드(records)로 알려진 행(row)으로 구성된다.\n스프레드쉬트를 사용할 때, 이전 값에 기초하여 새로운 값을 계산할 때 공식을 셀(cell)에 넣어서 구한다. 데이터베이스를 사용할 때는 쿼리(queries, 질의)로 불리는 명령문을 데이터베이스 관리자(database manager)에게 보낸다. 데이터베이스 관리자는 사용자를 대신해서 데이터베이스를 조작하는 프로그램이다. 데이터베이스 관리자는 쿼리가 명기하는 임의의 조회작업과 계산작업을 수행하고 다음 쿼리작업 시작점으로 사용될 수 있는 테이블 형식으로 결과값을 반환한다.\n\n\n\n\n\n\n데이터베이스 상호호환\n\n\n\n모든 데이터베이스 관리자(IBM DB2, PostgreSQL, MySQL, Microsoft Access, SQLite)는 서로 다른 고유한 방식으로 데이터를 저장하기 때문에, 특정 데이터베이스로 저장된 데이터를 다른 곳의 데이터베이스에서 직접적으로 사용할 수는 없다. 하지만, 모든 데이터베이스 관리자에는 데이터를 다양한 형식으로 가져오기(import)와 내보내기(export) 기능을 제공한다. 그래서 한 곳에서 다른 곳으로 정보를 이동하는 것이 가능하다.\n\n\n쿼리는 SQL로 불리는 언어로 작성된다. SQL 은 “Structured Query Language”(구조적 질의 언어)의 약자다. SQL은 데이터를 분석하고 다시 조합할 수 있는 수백개의 다른 방식을 제공한다. 본서에서 일부를 살펴볼 것이지만, 일부작업이 데이터 과학자가 수행하는 일의 대부분을 처리할 것이다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>데이터 선택하기</span>"
    ]
  },
  {
    "objectID": "select.html#조사-데이터베이스",
    "href": "select.html#조사-데이터베이스",
    "title": "3  데이터 선택하기",
    "section": "3.2 조사 데이터베이스",
    "text": "3.2 조사 데이터베이스\nSQLite를 사용하여 본격적인 쿼리문 작성에 앞서 실습에 사용될 데이터베이스 구조를 살펴보자.\n\n\nPerson: 측정값을 기록한 사람, id는 해당 인물을 위한 고유 식별자를 나타낸다.\n\n\n\nid\npersonal\nfamily\n\n\n\n\ndyer\nWilliam\nDyer\n\n\npb\nFrank\nPabodie\n\n\nlake\nAnderson\nLake\n\n\nroe\nValentina\nRoerich\n\n\ndanforth\nFrank\nDanforth\n\n\n\nSite: 측정값이 기록된 sites의 위치를 나타낸다.\n\n\n\nname\nlat\nlong\n\n\n\n\nDR-1\n-49.85\n-128.57\n\n\nDR-3\n-47.15\n-126.72\n\n\nMSK-4\n-48.87\n-123.4\n\n\n\nVisited: 측정 위지에서 측정값이 기록된 구체적인 위치와 날짜에 대한 특정 식별 id를 나타낸다.\n\n\n\nid\nsite\ndated\n\n\n\n\n619\nDR-1\n1927-02-08\n\n\n622\nDR-1\n1927-02-10\n\n\n734\nDR-3\n1930-01-07\n\n\n735\nDR-3\n1930-01-12\n\n\n751\nDR-3\n1930-02-26\n\n\n752\nDR-3\n-null-\n\n\n837\nMSK-4\n1932-01-14\n\n\n844\nDR-1\n1932-03-22\n\n\n\n\n\nSurvey: 각 측정지의 정확한 위치에서 취한 측정값들로, taken으로 식별된다. quant 필드는 ‘양’을 의미하는 줄임말로 측정 대상을 나타낸다. 값은 각각 ’방사능’, ‘염도’, ’온도’를 의미하는 rad, sal, temp로 표시된다.\n\n\n\ntaken\nperson\nquant\nreading\n\n\n\n\n619\ndyer\nrad\n9.82\n\n\n619\ndyer\nsal\n0.13\n\n\n622\ndyer\nrad\n7.8\n\n\n622\ndyer\nsal\n0.09\n\n\n734\npb\nrad\n8.41\n\n\n734\nlake\nsal\n0.05\n\n\n734\npb\ntemp\n-21.5\n\n\n735\npb\nrad\n7.22\n\n\n735\n-null-\nsal\n0.06\n\n\n735\n-null-\ntemp\n-26.0\n\n\n751\npb\nrad\n4.35\n\n\n751\npb\ntemp\n-18.5\n\n\n751\nlake\nsal\n0.1\n\n\n752\nlake\nrad\n2.19\n\n\n752\nlake\nsal\n0.09\n\n\n752\nlake\ntemp\n-16.0\n\n\n752\nroe\nsal\n41.6\n\n\n837\nlake\nrad\n1.46\n\n\n837\nlake\nsal\n0.21\n\n\n837\nroe\nsal\n22.5\n\n\n844\nroe\nrad\n11.25\n\n\n\n\n\n3개 항목 (Visited 테이블에서 1개, Survey 테이블에서 2개)은 실제 데이터가 아닌 특별한 -null- 항목을 가지고 있다. 왜냐하면 어떠한 값도 담고 있지 않아서 그렇다. 뒤에서 결측값(missing)을 다시 다룰 것이다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>데이터 선택하기</span>"
    ]
  },
  {
    "objectID": "select.html#데이터-유무-확인하기",
    "href": "select.html#데이터-유무-확인하기",
    "title": "3  데이터 선택하기",
    "section": "3.3 데이터 유무 확인하기",
    "text": "3.3 데이터 유무 확인하기\n쉘 명령으로, survey.db를 저장한 디렉토리로 작업 디렉토리를 변경한다. 만약 바탕화면에 저장했다면 다음 명령어를 사용해야 한다.\n$ cd Desktop\n$ ls | grep survey.db\nsurvey.db\n동일한 출력이 나오면 다음 명령어를 실행할 수 있다.\n$ sqlite3 survey.db\nSQLite version 3.8.8 2015-01-16 12:08:06\nEnter \".help\" for usage hints.\nsqlite&gt;\nSQLite에 survey.db 파일에 있는 데이터베이스를 로드하라는 명령어다.\n유용한 시스템 명령어 목록을 보려면 .help를 입력한다.\nSQLite 시스템 명령어들은 SQL 명령어와 구별하기 위해 .로 시작한다.\n데이터베이스의 테이블 목록을 보려면 .tables를 입력한다.\n.tables\nPerson   Site     Survey   Visited\nIf you had the above tables, you might be curious what information was stored in each table. To get more information on the tables, type .schema to see the SQL statements used to create the tables in the database. The statements will have a list of the columns and the data types each column stores.\n위와 같은 테이블이 있다면 각 테이블에 어떤 정보가 저장되어 있는지 궁금할 수 있다. 테이블에 대한 자세한 정보를 얻으려면 .schema를 입력해 데이터베이스의 테이블을 생성하는 데 사용된 SQL 문을 확인한다. 테이블명과 함께 테이블을 구성하는 칼럼과 칼럼 자료형이 목록으로 나열된다.\n.schema\nCREATE TABLE Person(\n        ident    text,\n        personal text,\n        family   text\n);\nCREATE TABLE Site(\n        name text,\n        lat  real,\n        long real\n);\nCREATE TABLE Visited(\n        ident integer,\n        site  text,\n        dated text\n);\nCREATE TABLE Survey(\n        taken   integer,\n        person  text,\n        quant   text,\n        reading real\n);\n출력 형식은 &lt;columnName dataType&gt;로 되어 있다. 따라서 첫 번째 줄에서 Person 테이블에 세 개의 열이 있음을 알 수 있다:\n\nid는 text 자료형\npersonal는 text 자료형\nfamily는 text 자료형\n\n참고: 사용 가능한 자료형은 데이터베이스 관리자에 따라 다르며, 지원되는 자료형은 온라인에서 검색할 수 있다.\nSQLite 설정을 변경하여 출력 가독성을 높일 수 있다. 먼저, 왼쪽 정렬 출력 모드를 설정한다. 그런 다음 칼럼명 헤더 표시를 켠다.\n.mode column\n.header on\n또 다른 방법으로, .sqliterc 파일을 생성하여 설정사항을 자동으로 가져올 수 있다. 위의 명령어를 추가하고 SQLite를 다시 연다. 윈도우에서는 C:\\Users\\&lt;yourusername&gt;.sqliterc를 사용한다. 리눅스와 맥(Linux/MacOS)에서는 /Users/&lt;yourusername&gt;/.sqliterc를 사용한다.\nSQLite를 종료하고 쉘 명령줄로 돌아가려면, .quit 또는 .exit를 사용하여 종료한다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>데이터 선택하기</span>"
    ]
  },
  {
    "objectID": "select.html#sql-헬로월드",
    "href": "select.html#sql-헬로월드",
    "title": "3  데이터 선택하기",
    "section": "3.4 SQL 헬로월드",
    "text": "3.4 SQL 헬로월드\n과학자의 이름을 화면에 표시하는 SQL 쿼리문을 작성해 보자. SQL SELECT 문을 사용해서 원하는 칼럼의 이름과 해당 열이 있는 테이블을 지정한다. 쿼리와 결과는 다음과 같다.\nSELECT family, personal FROM Person;\n\n\n\nfamily\npersonal\n\n\n\n\nDyer\nWilliam\n\n\nPabodie\nFrank\n\n\nLake\nAnderson\n\n\nRoerich\nValentina\n\n\nDanforth\nFrank\n\n\n\n쿼리 끝에 세미콜론(;)은 쿼리가 완료되어 실행준비 되었다고 데이터베이스 관리자에게 알린다. 명령문과 칼럼 이름을 모두 소문자로 작성했고, 테이블 이름은 타이틀 케이스(Title Case, 단어의 첫 문자를 대문자로 표기)로 작성했다. 하지만 그렇게 반듯이 할 필요는 없다. 아래 예제가 보여주듯이, SQL은 대소문자 구분하지 않는다(case insensitive).\nSeLeCt FaMiLy, PeRsOnAl FrOm PeRsOn;\n\n\n\nfamily\npersonal\n\n\n\n\nDyer\nWilliam\n\n\nPabodie\nFrank\n\n\nLake\nAnderson\n\n\nRoerich\nValentina\n\n\nDanforth\nFrank\n\n\n\n모두 소문자, 타이틀 케이스, 소문자 낙타 대문자(Lower Camel Case)를 선택하든지 관계없이 일관성을 가져라. 무작위 대문자를 추가적으로 인지하지 않더라고 복잡한 쿼리는 충분히 그 자체로 이해하기 어렵다.\nSQL의 대소문자 구분이 없는 특성을 이용해 SQL 문의 다른 부분을 구분할 수 있다. 일반적인 SQL 문 작성사례로, SQL 키워드(예: SELECT, FROM)는 대문자로, 테이블 이름은 타이틀 케이스로, 필드 이름은 소문자로 사용하는 관례를 따른다. 어떤 대소문자 사용 관례를 선택하든 일관성을 유지하는 것이 중요하다.\n\n\n\n\n\n\n노트\n\n\n\nSQL 구문의 한 측면인 ; (세미콜론)으로 명령을 마치지 않는 것은 초보자와 전문가 모두에게 혼란을 주고 있다. ;를 추가하지 않고 명령어를 입력한 후 엔터를 누르면 다음과 같은 상황이 발생한다.\nSELECT id FROM Person\n...&gt;\n...&gt;\n이것은 SQL이 추가 명령을 기다리거나 ;를 통해 SQL에게 명령을 마칠 준비가 되었음을 알리는 프롬프트다. 이 문제는 쉽게 해결할 수 있다! 단순히 ;를 입력하고 엔터를 누르면 된다!\n\n\n쿼리로 돌아가서, 데이터베이스 테이블의 행과 칼럼이 특정한 순서로 저장되어 있지 않는다는 것을 이해하는 것이 중요하다. 어떤 순서로 항상 표시되지만, 다양한 방식으로 출력을 제어할 수 있다. 예를 들어, 쿼리를 다음과 같이 작성해서 칼럼을 교환할 수 있다.\nSELECT personal, family FROM Person;\n\n\n\npersonal\nfamily\n\n\n\n\nWilliam\nDyer\n\n\nFrank\nPabodie\n\n\nAnderson\nLake\n\n\nValentina\nRoerich\n\n\nFrank\nDanforth\n\n\n\n혹은 심지어 칼럼을 반복할 수도 있다.\nSELECT id, id, id FROM Person;\n\n\n\nid\nid\nid\n\n\n\n\ndyer\ndyer\ndyer\n\n\npb\npb\npb\n\n\nlake\nlake\nlake\n\n\nroe\nroe\nroe\n\n\ndanforth\ndanforth\ndanforth\n\n\n\n손쉬운 방법으로, *을 사용해서 테이블의 모든 칼럼을 선택할 수도 있다.\nSELECT * FROM Person;\n\n\n\nid\npersonal\nfamily\n\n\n\n\ndyer\nWilliam\nDyer\n\n\npb\nFrank\nPabodie\n\n\nlake\nAnderson\nLake\n\n\nroe\nValentina\nRoerich\n\n\ndanforth\nFrank\nDanforth",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>데이터 선택하기</span>"
    ]
  },
  {
    "objectID": "select.html#연습문제",
    "href": "select.html#연습문제",
    "title": "3  데이터 선택하기",
    "section": "3.5 연습문제",
    "text": "3.5 연습문제\n\n3.5.1 CREATE 쿼리문\n데이터베이스 SQL 문을 작성할 때 테이블 칼럼 자료형(문자, 숫자, 날짜 등)을 파악하고 있어야 버그없는 깔끔한 쿼리를 작성할 수 있다.\n정수를 포함하는 칼럼을 확인하기 위해, .schema 명령어를 사용하면 확인할 수 있다.\n.schema\nCREATE TABLE Person (id text, personal text, family text);\nCREATE TABLE Site (name text, lat real, long real);\nCREATE TABLE Survey (taken integer, person text, quant text, reading real);\nCREATE TABLE Visited (id integer, site text, dated text);\n출력 결과에서, Survey 테이블(3번째 줄)의 taken 칼럼이 실수 자료형임을 확인할 수 있다.\n\n\n3.5.2 사이트 이름 선택하기\nSite 테이블에서 name 칼럼만 선택하는 쿼리를 작성한다.\nSELECT name FROM Site;\n\n\n\nname\n\n\n\n\nDR-1\n\n\nDR-3\n\n\nMSK-4\n\n\n\n\n\n3.5.3 쿼리 스타일\n많은 사람들은 쿼리를 다음과 같이 작성한다.\nSELECT personal, family FROM person;\n또는,\nselect Personal, Family from PERSON;\n어떤 스타일이 가장 읽기 쉽다고 생각하며, 그 이유는 무엇인가?\n읽기 쉬운 쿼리 스타일은 주로 개인적인 선호와 경험에 따라 달라질 수 있다. 그러나 일반적으로 첫 번째 예시처럼 SQL 키워드를 대문자로, 테이블과 칼럼 이름을 소문자로 쓰는 방식이 가독성이 높다고 여겨진다. SQL 키워드와 테이블, 칼럼 이름 사이의 명확한 구분을 제공하여 쿼리를 더 쉽게 읽고 이해할 수 있게 한다. 반면, 두 번째 예시처럼 모든 것을 소문자나 대문자로 쓰는 방식은 이러한 구분을 덜 명확하게 만들어 쿼리의 구조를 파악하기 어렵게 할 수 있다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>데이터 선택하기</span>"
    ]
  },
  {
    "objectID": "13-filter.html",
    "href": "13-filter.html",
    "title": "5  필터링 (Filtering)",
    "section": "",
    "text": "목표\n\n사용자가 정의한 조건을 만족하는 레코드를 선택하는 쿼리를 작성한다.\n쿼리 절이 실행되는 순서를 설명한다.\n\n\n데이터베이스의 가장 강력한 기능중 하나는 데이터를 필터(filter)하는 능력이다. 즉, 특정 기준에 맞는 레코드만 선택한다. 예를 들어, 특정 사이트를 언제 방문했는지 확인한다고 가정하자. 쿼리에 where 절을 사용해서 Visited 테이블로부터 레코드를 뽑아낼 수 있다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect * from Visited where site='DR-1';\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n데이터베이스 관리자는 두 단계로 나누어 쿼리를 실행한다. 첫번째로, where 절을 만족하는 것이 있는지 확인하기 위해서 Visited 테이블의 각 행을 점검한다. 그리고 나서 무슨 칼럼을 표시할지 결정하기 위해서 select 키워드 다음에 있는 칼럼 이름을 사용한다.\n이러한 처리 순서가 의미하는 바는 화면에 표시되지 않는 칼럼 값에 기반해서도 where 절을 사용해서 레코드를 필터링할 수 있다는 것이다.\n%%sqlite survey.db\nselect ident from Visited where site='DR-1';\n\n\n\n\n619\n\n\n\n\n622\n\n\n\n\n844\n\n\n\n\n\n데이터를 필터링하는데 불 연산자(Boolean Operators)를 사용할 수 있다. 예를 들어, 1930년 이후로 DR-1 사이트에서 수집된 모든 정보를 요청할 수도 있다.\n%%sqlite survey.db\nselect * from Visited where (site='DR-1') and (dated&gt;='1930-00-00');\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n(각 테스트 주위의 괄호는 엄밀히 말해 필요하지는 않지만 쿼리를 좀더 읽기 쉽게 한다.)\n\n대부분의 데이터베이스 관리자는 날짜에 대한 특별한 데이터 형식을 가진다. 사실 많이 있지만 두가지 형식으로 볼 수 있다. 날짜 데이터 형식의 하나는 “May 31, 1971”와 같은 것이고, 다른 하나는 “31 days” 같은 기간에 대한 것이다. SQLite는 구분하지는 않는다. 대신에 SQLite는 날짜를 텍스트 (ISO-8601 표준 형식 “YYYY-MM-DD HH:MM:SS.SSSS”), 혹은 실수 (November 24, 4714 BCE 이후 지나간 일수), 혹은 정수 (1970년 1월 1일 자정 이후 초)로만 저장한다. 만약 복잡하게 들린다면, 그럴수도 있다 하지만 스웨덴의 역사적인 날짜(historical dates in Sweden)를 이해하는 것만큼 복잡하는지는 않다.\n\nLake 혹은 Roerich가 무슨 측정을 했는지 알아내고자 한다면, or를 사용하여 이름에 테스트를 조합할 수 있다.\n%%sqlite survey.db\nselect * from Survey where person='lake' or person='roe';\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nrad\n\n\n2.19\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nlake\n\n\ntemp\n\n\n-16.0\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nrad\n\n\n1.46\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\n다른 방식으로, in을 사용하여 특정 집합에 값이 있는지 확인할 수 있다.\n%%sqlite survey.db\nselect * from Survey where person in ('lake', 'roe');\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nrad\n\n\n2.19\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nlake\n\n\ntemp\n\n\n-16.0\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nrad\n\n\n1.46\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\nand와 or를 조합할 수는 있지만, 어느 연산자가 먼저 수행되는지 주의할 필요가 있다. 만약 괄호를 사용하지 않는다면, 다음을 얻게 된다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and person='lake' or person='roe';\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\n상기 결과는 Lake가 측정한 염분량과 Roerich가 측정한 임의 측정값이다. 대신에 아마도 다음과 같은 결과를 얻고자 했을 것이다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and (person='lake' or person='roe');\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n마지막으로 distinct와 where를 사용하여 두번째 수준의 필터링을 한다.\n%%sqlite survey.db\nselect distinct person, quant from Survey where person='lake' or person='roe';\n\n\n\n\nlake\n\n\nsal\n\n\n\n\nlake\n\n\nrad\n\n\n\n\nlake\n\n\ntemp\n\n\n\n\nroe\n\n\nsal\n\n\n\n\nroe\n\n\nrad\n\n\n\n\n하지만, 기억하라. distinct는 처리될 때 선택된 칼럼에 표시되는 값에만 적용되고 전체 행에는 적용되지 않는다.\n\n방금전까지 수행하는 것은 대부분의 사람들이 어떻게 SQL 쿼리를 증가시키는지 살펴봤다. 의도한 것의 일부를 수행하는 단순한 것에서부터 시작했다. 그리고 절을 하나씩 하나씩 추가하면서 효과를 테스트했다. 좋은 전략이다. 사실 복잡한 쿼리를 작성할 때, 종종 유일한 전략이다. 하지만 이 전략은 빠른 회전(turnaround)시간에 달려있고 사용자에게는 정답을 얻게되면 인지하는 것에 달려있다. 빠른 회전시간을 달성하는 최선의 방법은 임시 데이터베이스에 데이터의 일부를 저장하고 쿼리를 실행하거나 혹은 합성된 레코드로 작은 데이터베이스를 채워놓고 작업을 하는 것이다. 예를 들어, 2천만 호주사람의 실제 데이터베이스에 쿼리를 작업하지 말고, 1만명 샘플을 뽑아 쿼리를 돌리거나 작은 프로그램을 작성해서 랜덤으로 혹은 그럴듯한 1만명 레코드를 생성해서 사용한다.\n\n\n도전 과제\n\n극에서 30&deg보다 고위도에 위치한 모든 사이트를 선택하고자 한다고 가정하자. 작성한 첫번째 쿼리는 다음과 같다.\nselect * from Site where (lat &gt; -60) or (lat &lt; 60);\n왜 이 쿼리가 잘못된 것인지 설명하세요. 그리고 쿼리를 다시 작성해서 올바르게 동작하게 만드세요.\n정규화된 염분 수치는 0.0에서 1.0 사이에 있어야 한다. 상기 범위 밖에 있는 염분수치를 가진 모든 레코드를 Survey 테이블에서 선택하는 쿼리를 작성하세요.\n만약 명명된 칼럼의 값이 주어진 패턴과 일치한다면 SQL 테스트 *column-name* like *pattern*은 참이다. “0 혹은 그 이상의 문자와 매칭”된다는 것을 의미하기 위해서 ’%’문자를 패턴에 임의 숫자 횟수에 사용한다.\n\n\n\n표현식\n\n\n값\n\n\n\n\n‘a’ like ‘a’\n\n\nTrue\n\n\n\n\n‘a’ like ‘%a’\n\n\nTrue\n\n\n\n\n‘b’ like ‘%a’\n\n\nFalse\n\n\n\n\n‘alpha’ like ‘a%’\n\n\nTrue\n\n\n\n\n‘alpha’ like ‘a%p%’\n\n\nTrue\n\n\n\n표현식 *column-name* not like *pattern*은 테스트를 거꾸로 한다. like를 사용하여 사이트에서 ’DR-something’으로 라벨이 붙지 않은 모든 레코드를 Visited에서 찾는 쿼리를 작성하세요.\n\n\n\n주요점\n\nwhere를 사용해서 불 조건(Boolean conditions)에 따라 레코드를 필터링한다.\n필터링이 전체 레코드에 적용되어서, 조건을 실제로 표시되지 않는 필드에 사용할 수 있다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>필터링 (Filtering)</span>"
    ]
  },
  {
    "objectID": "14-calc.html",
    "href": "14-calc.html",
    "title": "6  새로운 값 계산하기",
    "section": "",
    "text": "목표\n\n각 선택된 레코드에 대해 새로운 값을 계산하는 쿼리를 작성한다.\n\n\n주의깊이 탐험 기록을 다시 정독한 뒤에, 탐험대가 보고한 방사선 측정치가 5%만큼 상향되어 수정될 필요가 있다는 것을 깨달았다. 저장된 데이터를 변형하기 보다는 쿼리의 일부분으로서 즉석에서 계산을 수행할 수 있다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect 1.05 * reading from Survey where quant='rad';\n\n\n\n\n10.311\n\n\n\n\n8.19\n\n\n\n\n8.8305\n\n\n\n\n7.581\n\n\n\n\n4.5675\n\n\n\n\n2.2995\n\n\n\n\n1.533\n\n\n\n\n11.8125\n\n\n\n\n쿼리를 실행하면, 표현식 1.05 * reading이 각 행마다 평가된다. 표현식에는 임의의 필드, 통상 많이 사용되는 연산자, 그리고 다양한 함수를 사용한다. (정확하게는 어느 데이터베이스 관리자를 사용되느냐에 따라 의존성을 띄게된다.) 예를 들어, 온도 측정치를 화씨에서 섭씨로 소수점 아래 두자리에서 반올림하여 변환할 수 있다.\n%%sqlite survey.db\nselect taken, round(5*(reading-32)/9, 2) from Survey where quant='temp';\n\n\n\n\n734\n\n\n-29.72\n\n\n\n\n735\n\n\n-32.22\n\n\n\n\n751\n\n\n-28.06\n\n\n\n\n752\n\n\n-26.67\n\n\n\n\n다른 필드의 값을 조합할 수도 있다. 예를 들어, 문자열 접합 연산자 (string concatenation operator, ||)를 사용한다.\n%%sqlite survey.db\nselect personal || ' ' || family from Person;\n\n\n\n\nWilliam Dyer\n\n\n\n\nFrank Pabodie\n\n\n\n\nAnderson Lake\n\n\n\n\nValentina Roerich\n\n\n\n\nFrank Danforth\n\n\n\n\n\nfirst와 last 대신에 필드 이름으로 personal과 family를 사용하는 것이 이상해 보일지 모른다. 하지만, 문화적 차이를 다루기 위한 필요한 첫번째 단계다. 예를 들어, 다음 규칙을 고려해보자.\n\n\n\n\n성명 전부(Full Name)\n\n\n알파벳 순서\n\n\n이유\n\n\n\n\nLiu Xiaobo\n\n\nLiu\n\n\n중국 성이 이름보다 먼저 온다.\n\n\n\n\nLeonardo da Vinci\n\n\nLeonardo\n\n\n“da Vinci” 는 “from Vinci”를 뜻한다.\n\n\n\n\nCatherine de Medici\n\n\nMedici\n\n\n성(family name)\n\n\n\n\nJean de La Fontaine\n\n\nLa Fontaine\n\n\n성(family name)이 “La Fontaine”이다.\n\n\n\n\nJuan Ponce de Leon\n\n\nPonce de Leon\n\n\n전체 성(full family name)이 “Ponce de Leon”이다.\n\n\n\n\nGabriel Garcia Marquez\n\n\nGarcia Marquez\n\n\n이중으로 된 스페인 성(surnames)\n\n\n\n\nWernher von Braun\n\n\nvon or Braun\n\n\n독일 혹은 미국에 있는냐에 따라 달라짐\n\n\n\n\nElizabeth Alexandra May Windsor\n\n\nElizabeth\n\n\n군주가 통치하는 이름에 따라 알파벳순으로 정렬\n\n\n\n\nThomas a Beckett\n\n\nThomas\n\n\n시성된(canonized) 이름에 따라 성인이름 사용\n\n\n\n\n분명하게, 심지어 두부분 “personal”과 “family”으로 나누는 것도 충분하지 않다.\n\n\n도전 과제\n\n좀더 조사한 뒤에, Valentina Roerich는 염도를 퍼센티지(%)로 작성한 것을 알게되었다. Survey 테이블에서 값을 100으로 나누어서 모든 염도 측정치를 반환하는 쿼리를 작성하세요.\nunion 연산자는 두 쿼리의 결과를 조합한다.\n\n%%sqlite survey.db\nselect * from Person where ident='dyer' union select * from Person where ident='roe';\n\n\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\nunion을 사용하여 앞선 도전과제에서 기술되어 수정된 Roerich가 측정한, Roerich만 측정한 염도 측정치의 통합 리스트를 생성하세요. 출력결과는 다음과 같아야 한다.\n\n\n\n619\n\n\n0.13\n\n\n\n\n622\n\n\n0.09\n\n\n\n\n734\n\n\n0.05\n\n\n\n\n751\n\n\n0.1\n\n\n\n\n752\n\n\n0.09\n\n\n\n\n752\n\n\n0.416\n\n\n\n\n837\n\n\n0.21\n\n\n\n\n837\n\n\n0.225\n\n\n\n\nVisited 테이블에 사이트 식별자는 ’-’으로 구분되는 두 부분으로 구성되어 있다.\n\n%%sqlite survey.db\nselect distinct site from Visited;\n\n\n\n\nDR-1\n\n\n\n\nDR-3\n\n\n\n\nMSK-4\n\n\n\n\n몇몇 주요 사이트 식별자는 두 문자길이를 가지고 몇몇은 3문자길이를 가진다. “in string” 함수 instr(X, Y)은 X 문자열에 문자열 Y가 첫번째 출현의 1-기반 인덱스를 반환하거나 Y가 X에 존재하지 않으면 0 을 반환한다. 부분 문자열 함수 substr(X, I)은 인덱스 I에서 시작하는 문자열 X의 부분문자열을 반환한다. 상기 두 함수를 사용해서 유일한 주요 사이트 식별자를 생성하세요. (이 데이터에 대해서 작업된 리스트는 “DR”과 “MSK”만 포함해야 한다.)\n\n\n주요점\n\nSQL은 쿼리의 일부로서 레코드의 값을 사용한 계산을 수행한다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>새로운 값 계산하기</span>"
    ]
  },
  {
    "objectID": "15-null.html",
    "href": "15-null.html",
    "title": "7  결측 데이터 (Missing Data)",
    "section": "",
    "text": "목표\n\n데이터베이스가 어떻게 결측 정보를 표현하는지 설명한다.\n결측 정보를 다룰 때, 3개 값을 가진 로직(three-valued logic) 데이터베이스 사용을 설명한다.\n결측 정보를 올바르게 처리하는 쿼리를 작성한다.\n\n\n현실 세계 데이터는 결코 완전하지 않고 구멍은 항상 있다. null로 불리는 특별한 값을 사용하여 데이터베이스는 구멍을 표현한다. null는 0, False, 혹은 빈 문자열도 아니다.”아무것도 없음(nothing here)“을 의미하는 특별한 값이다. null을 다루는 것은 약간 특별한 기교와 신중한 생각을 요구한다.\n시작으로 Visited 테이블을 살펴보자. 레코드가 8개 있지만 #752은 날짜가 없다. 혹은 더 정확히 말하면 날짜가 null이다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect * from Visited;\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nNull 다른 값과는 다르게 동작한다. 만약 1930년 이전 레코드를 선택한다면,\n%%sqlite survey.db\nselect * from Visited where dated&lt;'1930-00-00';\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n결과 2개를 얻게 되고, 만약 1930년 동안 혹은 이후 레코드를 선택한다면,\n%%sqlite survey.db\nselect * from Visited where dated&gt;='1930-00-00';\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n결과를 5개 얻게되지만, 레코드 #752은 결과값 어디에도 존재하지 않는다. 이유는 null&lt;'1930-00-00' 평가결과가 참도 거짓도 아니기 때문이다. null 이 의미하는 것은 “알수가 없다”는 것이다. 그리고 만약 비교 평가식의 왼쪽편 값을 알지 못한다면, 비교도 참인지 거짓인지 알수가 없다. 데이터베이스는 “알 수 없음”을 null로 표현하기 때문에, null&lt;'1930-00-00'의 값도 사실 null이다. null&gt;='1930-00-00'도 또한 null인데 왜냐하면 질문에 답을 할 수 없기 때문이다. 그리고, where절에 레코드는 테스트가 참인 것만 있기 때문에 레코드 #752은 어느 결과값에도 포함되지 않게 된다.\n평가식만 null값을 이와 같은 방식으로 다루는 연산자는 아니다. 1+null도 null이고, 5*null도 null이고, log(null)도 null이 된다. 특히, 무언가를 = 과 != 으로 null과 비교하는 것도 null이 된다.\n%%sqlite survey.db\nselect * from Visited where dated=NULL;\n\n\n\n\n%%sqlite survey.db\nselect * from Visited where dated!=NULL;\n\n\n\n\nnull 인지 아닌지를 점검하기 위해서, 특별한 테스트 is null을 사용해야 한다.\n%%sqlite survey.db\nselect * from Visited where dated is NULL;\n\n\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\n혹은, 역으로는 is not null을 사용한다.\n%%sqlite survey.db\nselect * from Visited where dated is not NULL;\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nnull 값은 나타나는 곳마다 두통을 일으킨다. 예를 들어, Dyer가 측정하지 않은 모든 염분 정보를 찾는다고 가정하자. 다음과 같이 쿼리를 작성하는 것은 당연하다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and person!='lake';\n\n\n\n\n619\n\n\ndyer\n\n\nsal\n\n\n0.13\n\n\n\n\n622\n\n\ndyer\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n하지만, 상기 쿼리 필터는 누가 측정을 했는지 모르는 레코드는 빠뜨린다. 다시 한번, 이유는 person이 null일 때, !=비교는 null값을 만들어서 레코드가 결과값에 있지 않게 된다. 만약 이런 레코드도 유지하려고 한다면, 명시적으로 검사를 추가할 필요가 있다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and (person!='lake' or person is null);\n\n\n\n\n619\n\n\ndyer\n\n\nsal\n\n\n0.13\n\n\n\n\n622\n\n\ndyer\n\n\nsal\n\n\n0.09\n\n\n\n\n735\n\n\nNone\n\n\nsal\n\n\n0.06\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n여전히 이러한 접근법이 맞는 것인지 아닌 것인지 판단할 필요가 있다. 만약 절대적으로 결과에 Lake가 측정한 어떠한 값도 포함하지 않는다고 확신한다면, 누가 작업을 한 것인지 모르는 모든 레코드를 제외할 필요가 있다.\n\n도전 과제\n\n날짜가 알려지지 않은 (즉 null) 항목은 빼고, 날짜 순으로 Visited 테이블에 있는 레코드를 정렬한 쿼리를 작성하세요.\n다음 쿼리가 무슨 결과를 할까요?\nselect * from Visited where dated in ('1927-02-08', null);\n상기 쿼리가 실질적으로 무엇을 생기게 할까요?\n몇몇 데이터베이스 디자이너는 null 보다 결측 데이터를 표기하기 위해서 보초값(sentinel value)를 사용한다. 예를 들어, 결측 날짜를 표기하기 위해서 “0000-00-00” 날짜를 사용하거나 결측 염분치 혹은 결측 방사선 측정값을 표기하기 위해서 -1.0을 사용한다. (왜냐하면 실제 측정값이 음수가 될 수 없기 때문이다.) 이러한 접근법은 무엇을 단순화할까요? 이러한 접근법이 어떤 부담과 위험을 가져올까요?\n\n\n\n주요점\n\n데이터베이스는 결측 정보를 표현하기 위해서 null을 사용한다.\nnull이 관계되는 산술 혹은 불 연산 결과도 null이다.\nnull과 함께 안전하세 사용될 수 있는 유일한 연산자는 is null과 is not null이다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>결측 데이터 (Missing Data)</span>"
    ]
  },
  {
    "objectID": "16-agg.html",
    "href": "16-agg.html",
    "title": "8  집합(Aggregation)",
    "section": "",
    "text": "목표\n\n“집합(aggregation)을 정의하고 사용예를 제시한다.\n집합하는 값을 계산하는 쿼리를 작성한다.\n집합을 수행하는 쿼리의 실행을 추적한다.\n결측 데이터가 어떻게 집합되는 동안에 다뤄지는지 설명한다.\n\n\n이제 데이터의 평균과 범위를 계산하고자 한다. Visited 테이블에서 모든 날짜 정보를 어떻게 선택하는지 알고 있다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect dated from Visited;\n\n\n\n\n1927-02-08\n\n\n\n\n1927-02-10\n\n\n\n\n1939-01-07\n\n\n\n\n1930-01-12\n\n\n\n\n1930-02-26\n\n\n\n\nNone\n\n\n\n\n1932-01-14\n\n\n\n\n1932-03-22\n\n\n\n\n하지만 조합하기 위해서는 min 혹은 max 같은 집합 함수(aggregation function)를 사용해야만 한다. 각 함수는 입력으로 레코드 집합을 받고 출력으로 단일 레코드를 만든다.\n%%sqlite survey.db\nselect min(dated) from Visited;\n\n\n\n\n1927-02-08\n\n\n\n\n\n%%sqlite survey.db\nselect max(dated) from Visited;\n\n\n\n\n1939-01-07\n\n\n\n\nmin과 max는 SQL에 내장된 단지 두개의 집합 함수다. 다른 세개는 avg, count, sum이 있다.\n%%sqlite survey.db\nselect avg(reading) from Survey where quant='sal';\n\n\n\n\n7.20333333333\n\n\n\n\n%%sqlite survey.db\nselect count(reading) from Survey where quant='sal';\n\n\n\n\n9\n\n\n\n\n%%sqlite survey.db\nselect sum(reading) from Survey where quant='sal';\n\n\n\n\n64.83\n\n\n\n\n여기서 count(reading)을 사용했다. 하지만 quant를 단순히 쉽게 세거나 테이블의 다른 어떤 필드도 셀 수 있고 심지어 count(*)을 사용하기도 한다. 왜냐하면 count()함수가 값 자체보다는 얼마나 많은 값이 있는지에만 관심을 두기 때문이다.\nSQL이 여러개의 집합연산도 한번에 수행한다. 예를 들어, 염분측정치의 범위도 알 수 있다.\n%%sqlite survey.db\nselect min(reading), max(reading) from Survey where quant='sal' and reading&lt;=1.0;\n\n\n\n\n0.05\n\n\n0.21\n\n\n\n\n출력결과가 놀라움을 줄 수도 있지만, 원 결과값과 집합 결과를 조합할 수도 있다.\n%%sqlite survey.db\nselect person, count(*) from Survey where quant='sal' and reading&lt;=1.0;\n\n\n\n\nlake\n\n\n7\n\n\n\n\n왜 Roerich 혹은 Dyer가 아닌 Lake의 이름이 나타날까요? 답은 필드를 집합하지만 어떻게 집합하는지 말을 하지 않기 때문에 데이터베이스 관리자가 입력에서 실제 값을 고른다. 처음 처리된 것, 마지막에 처리된 것, 혹은 완전히 다른 무언가를 사용할 수도 있다.\n또다른 중요한 사실은 집합할 어떠한 값도 없을 때, 집합 결과는 0 혹은 다른 임의의 값 보다 “알지 못한다(don’t know)”가 된다.\n%%sqlite survey.db\nselect person, max(reading), sum(reading) from Survey where quant='missing';\n\n\n\n\nNone\n\n\nNone\n\n\nNone\n\n\n\n\n집합 함수의 마지막 중요한 한가지 기능은 매우 유용한 방식으로 나머지 SQL과는 일관되지 않다는 것이다. 만약 두 값을 더하는데 그중 하나가 null이면 결과는 null이다. 확장해서, 만약 한 집합의 모든 값을 더하기 위해서 sum을 사용하고 이들 중 임의의 값이 null이면, 결과도 또한 null이어야 한다. 하지만 집합함수가 null 값을 무시하고 단지 non-null 값만을 조합한다면 훨씬 더 유용하다. 명시적으로 항상 필터해야하는 대신에 이것의 결과 쿼리를 다음과 같이 작성할 수 있게 한다.\n%%sqlite survey.db\nselect min(dated) from Visited;\n\n\n\n\n1927-02-08\n\n\n\n\n명시적으로 항상 다음과 같이 필터하는 쿼리를 작성할 필요가 없다.\n%%sqlite survey.db\nselect min(dated) from Visited where dated is not null;\n\n\n\n\n1927-02-08\n\n\n\n\n한번에 모든 레코드를 집합하는 것이 항상 타당하지는 않다. 예를 들어, Gina가 데이터에 체계적인 편의(bias)가 있어서 다른 과학자의 방사선 측정치가 다른 사람의 것과 비교하여 높다고 의심한다고 가정하자. 다음 쿼리가 의도를 반영하여 동작하지 않는다는 것은 알고 있다.\n%%sqlite survey.db\nselect person, count(reading), round(avg(reading), 2)\nfrom  Survey\nwhere quant='rad';\n\n\n\n\nroe\n\n\n8\n\n\n6.56\n\n\n\n\n왜냐하면 데이터베이스 관리자가 각 과학자별로 구분된 집합하기 보다는 임의의 한명의 과학자 이름만 선택하기 때문이다. 단지 5명의 과학자만 있기 때문에, 다음과 같은 형식의 5개 쿼리를 작성할 수 있다.\n%%sqlite survey.db\nselect person, count(reading), round(avg(reading), 2)\nfrom  Survey\nwhere quant='rad'\nand   person='dyer';\n\n\n\n\ndyer\n\n\n2\n\n\n8.81\n\n\n\n\n하지만, 이러한 접근법은 성가시고, 만약 50명 혹은 500명의 과학자를 가진 데이터셋을 분석한다면, 모든 쿼리를 올바르게 작성할 가능성은 작다.\n필요한 것은 데이터베이스 관리자가 group by절을 사용해서 각 과학자별로 시간을 집합하도록 지시하는 것이다.\n%%sqlite survey.db\nselect   person, count(reading), round(avg(reading), 2)\nfrom     Survey\nwhere    quant='rad'\ngroup by person;\n\n\n\n\ndyer\n\n\n2\n\n\n8.81\n\n\n\n\nlake\n\n\n2\n\n\n1.82\n\n\n\n\npb\n\n\n3\n\n\n6.66\n\n\n\n\nroe\n\n\n1\n\n\n11.25\n\n\n\n\ngroup by는 이름이 의미하는 것과 동일한 것을 정확하게 수행한다. 지정된 필드에 동일한 값을 가진 모든 레코드를 그룹으로 묶어서 집합을 각 배치별로 처리한다. 각 배치에 모든 레코드는 person에 동일한 값을 가지고 있기 때문에, 데이터베이스 관리자가 임의의 값을 잡아서 집합된 reading 값과 함께 표시하는지는 더 이상 문제가 되지 않는다.\n한번에 다중 기준으로 정렬하듯이 다중 기준으로 묶어 그룹화할 수 있다. 예를 들어 과학자와 측정 수량에 따라 평균 측정값을 얻기 위해서, group by 절에 또다른 필드만 추가한다.\n%%sqlite survey.db\nselect   person, quant, count(reading), round(avg(reading), 2)\nfrom     Survey\ngroup by person, quant;\n\n\n\n\nNone\n\n\nsal\n\n\n1\n\n\n0.06\n\n\n\n\nNone\n\n\ntemp\n\n\n1\n\n\n-26.0\n\n\n\n\ndyer\n\n\nrad\n\n\n2\n\n\n8.81\n\n\n\n\ndyer\n\n\nsal\n\n\n2\n\n\n0.11\n\n\n\n\nlake\n\n\nrad\n\n\n2\n\n\n1.82\n\n\n\n\nlake\n\n\nsal\n\n\n4\n\n\n0.11\n\n\n\n\nlake\n\n\ntemp\n\n\n1\n\n\n-16.0\n\n\n\n\npb\n\n\nrad\n\n\n3\n\n\n6.66\n\n\n\n\npb\n\n\ntemp\n\n\n2\n\n\n-20.0\n\n\n\n\nroe\n\n\nrad\n\n\n1\n\n\n11.25\n\n\n\n\nroe\n\n\nsal\n\n\n2\n\n\n32.05\n\n\n\n\n그렇지 않으면 결과가 의미가 없기 때문에, person을 표시되는 필드 리스트에 추가한 것을 주목하라.\n한단계 더나아가 누가 측정을 했는지 알지 못하는 모든 항목을 제거하자.\n%%sqlite survey.db\nselect   person, quant, count(reading), round(avg(reading), 2)\nfrom     Survey\nwhere    person is not null\ngroup by person, quant\norder by person, quant;\n\n\n\n\ndyer\n\n\nrad\n\n\n2\n\n\n8.81\n\n\n\n\ndyer\n\n\nsal\n\n\n2\n\n\n0.11\n\n\n\n\nlake\n\n\nrad\n\n\n2\n\n\n1.82\n\n\n\n\nlake\n\n\nsal\n\n\n4\n\n\n0.11\n\n\n\n\nlake\n\n\ntemp\n\n\n1\n\n\n-16.0\n\n\n\n\npb\n\n\nrad\n\n\n3\n\n\n6.66\n\n\n\n\npb\n\n\ntemp\n\n\n2\n\n\n-20.0\n\n\n\n\nroe\n\n\nrad\n\n\n1\n\n\n11.25\n\n\n\n\nroe\n\n\nsal\n\n\n2\n\n\n32.05\n\n\n\n\n좀더 면밀하게 살펴보면, 이 쿼리는,\n\nSurvey테이블에서 person 필드가 null이 아닌 레코드를 선택한다.\n상기 레코드를 부분집합으로 그룹지어서 각 부분집합의 person과 quant의 값은 같다.\n먼저 person으로 부분집합을 정렬하고나서 quant로 각 하위 그룹내에서도 정렬한다.\n각 부분집합의 레코드 숫자를 세고, 각각 reading 평균을 계산하고, 각각 person과 quant 값을 선택한다. (모두 동등하기 때문에 어느 것인지는 문제가 되지 않는다.)\n\n\n도전 과제\n\nFrank Pabodie는 얼마 많이 온도 측정치를 기록했고 평균 값은 얼마인가요?\n집합 값의 평균은 값을 합한 것을 값의 갯수로 나눈 것이다. 값이 1.0, null, 5.0 으로 주어졌을 때, avg 함수는 2.0 혹은 3.0을 반환하는 것을 의미하나요?\n각 개별 방사선 측정값과 평균값 사이의 차이를 계산하고자 한다. 쿼리를 다음과 같이 작성한다.\nselect reading - avg(reading) from Survey where quant='rad';\n상기 쿼리가 무엇을 만드나요? 그리고 왜 그런가요?\ngroup_concat(field, separator) 함수는 지정된 구분 문자(혹은 만약 구분자가 지정되지 않는다면 ‘,’)를 사용하여 필드의 모든 값을 결합한다. 이 함수르 사용해서 과학자의 이름을 한줄 리스트로 다음과 같이 만드세요.\nWilliam Dyer, Frank Pabodie, Anderson Lake, Valentina Roerich, Frank Danforth\n성씨(surname)으로 리스트를 정렬하는 방법을 제시할 수 있나요?\n\n\n\n주요점\n\n집합 함수는 많은 값을 조합해서 하나의 새로운 값을 만든다.\n집합 함수는 null 값을 무시한다.\n필터링 다음에 집합이 일어난다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>집합(Aggregation)</span>"
    ]
  },
  {
    "objectID": "17-join.html",
    "href": "17-join.html",
    "title": "9  데이터 조합하기 (Combining Data)",
    "section": "",
    "text": "목표\n\n두 테이블을 조인(join)하는 쿼리 연산을 설명한다.\n의미있는 값의 조합만 포함하기 위해서 조인문을 포함하는 쿼리 결과를 어떻게 제한하는지 설명한다.\n동일한 키를 갖는 테이블을 조인하는 쿼리를 작성한다.\n기본키(primary key)와 외래키(foreign key)가 무엇인지 그리고 왜 유용한지 설명한다.\n원자값(atomic value)이 무엇이고, 왜 데이터베이스 필드는 원자값만 포함해야하는지 설명한다.\n\n\n과거 기상 자료를 집계하는 웹사이트에 데이터를 제출해야 되어서, Gina는 위도, 경도, 날짜, 수량, 측정값 형식으로 자료를 체계적으로 만들 필요가 있다. 하지만, 위도와 경도 정보는 Site 테이블에 있는 반면에 측정 날짜 정보는 Visited 테이블에 있고, 측정값 자체는 Survey 테이블에 있다. 어떤 방식이든지 상기 테이블을 조합할 필요가 있다.\n이러한 작업을 하는 SQL 명령어가 join이다. 어떻게 동작하는지 확인하기 위해서, Site와 Visited 테이블을 조인하면서 출발해보자.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect * from Site join Visited;\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\njoin은 두 테이블을 외적(cross product)한다. 즉, 모든 가능한 조합을 표현하려고 한 테이블의 레코드 각각마다 다른 테이블의 각 레코드와 조인한다. Site 테이블에 3개 레코드가 있고, Visited 테이블에 8개 레코드가 있어서, 조인된 결과는 24개 레코드가 된다. 그리고, 각 테이블이 3개 필드가 있어서 출력은 6개의 필드가 된다.\n조인이 수행하지 않은 것은 조인되는 레코드가 서로 관계가 있는지를 파악하는 것이다. 어떻게 조인할지 명시할 때까지 레코드가 서로 관계가 있는지 없는지 알 수 있는 방법은 없다. 이를 위해서 동일한 사이트 이름을 가진 조합에만 관심있다는 것을 명시하는 절(clause)을 추가한다.\n%%sqlite survey.db\nselect * from Site join Visited on Site.name=Visited.site;\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\non 은 where와 같은 역할을 한다. 특정 테스트를 통과한 레코드만 간직한다. (on과 where의 차이점은 on은 레코드가 생성될 때 레코드를 필터링하는 반면에, where는 조인작업이 완료될 때까지 기다리고 난 뒤에 필터링을 한다.) 쿼리에 레코드를 추가하자 마자 데이터베이스 관리자는 두 다른 사이트에 관한 조합된 정보는 사용한 뒤에 버려버리고, 원하는 레코드만 남겨둔다.\n조인 결과에 필드이름을 명기하기 위해서 table.field를 사용한 것에 주목하세요. 이렇게 하는 이유는 테이블이 동일한 이름을 가질 수 있고 어느 필드를 언급하는지 좀더 구체성을 띌 필요가 있다. 예를 들어, person과 visited 테이블을 조인한다면, 결과는 각각의 원래 테이블에서 ident로 불리는 필드를 상속한다.\n이제는 조인에서 원하는 3개의 칼럼을 선택하려고 점 표기법(dotted notation)을 사용할 수 있다.\n%%sqlite survey.db\nselect Site.lat, Site.long, Visited.dated\nfrom   Site join Visited\non     Site.name=Visited.site;\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1932-03-22\n\n\n\n\n-47.15\n\n\n-126.72\n\n\nNone\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\n\n\n만약 두개의 테이블을 조인하는 것이 좋은 경우에, 많은 데이블을 조인하는 것은 더 좋아야한다. 더 많은 join 절과 의미없는 레코드 조합을 필터링해서 제거하는 더 많은 on 테스트를 단순히 추가해서 사실 쿼리에 임의 갯수의 테이블을 조인할 수 있다.\n%%sqlite survey.db\nselect Site.lat, Site.long, Visited.dated, Survey.quant, Survey.reading\nfrom   Site join Visited join Survey\non     Site.name=Visited.site\nand    Visited.ident=Survey.taken\nand    Visited.dated is not null;\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\nrad\n\n\n9.82\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\nsal\n\n\n0.13\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\nrad\n\n\n7.8\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\nsal\n\n\n0.09\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\nrad\n\n\n8.41\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\nsal\n\n\n0.05\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\ntemp\n\n\n-21.5\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\nrad\n\n\n7.22\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\nsal\n\n\n0.06\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\ntemp\n\n\n-26.0\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\nrad\n\n\n4.35\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\nsal\n\n\n0.1\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\ntemp\n\n\n-18.5\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\nrad\n\n\n1.46\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\nsal\n\n\n0.21\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\nsal\n\n\n22.5\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1932-03-22\n\n\nrad\n\n\n11.25\n\n\n\n\nSite, Visited, Survey 테이블의 어느 레코드가 서로 대응되지는 분간할 수 있는데 이유는 각 테이블이 기본키(primary keys)와 외래키(foreign keys)를 가지고 있기 때문이다.. 기본키는 하나의 값 혹은 여러 값의 조합으로 테이블의 각 레코드를 유일하게 식별한다. 외래키는 또 다른 테이블에 있는 유일하게 레코드를 식별하는 하나의 값(혹은 여러 값의 조합)이다. 다르게 표현하면, 외래캐는 다른 테이블에 존재하는 테이블의 기본키다. 예제 데이터베이스에서 Person.ident는 Person 테이블의 기본키인 반면에, Survey.person은 외래키로 Survey 테이블의 항목과 Person 테이블의 항목을 연결한다.\n대부분의 데이터베이스 디자이너는 모든 테이블은 잘 정의된 기본키가 있어야된다고 믿는다. 또한 이 키는 데이터와 떨어져서 만약 데이터를 변경할 필요가 있다면, 한 곳의 변경이 한 곳에만 변경을 만들어야만 한다. 이를 위한 쉬운 방법은 데이터베이스에 레코드를 추가할 때 임의의 유일한 ID를 각 레코드마다 추가하는 것이다. 실제로 이방법은 매우 흔하게 사용된다. “student numbers”, “patient numbers” 같은 이름을 ID로 사용하고, 몇몇 데이터베이스 시스템 혹은 다른 곳에서 원래 고유 레코드 식별자로 거의 항상 판명된다. 다음 쿼리가 시범으로 보여주듯이, 테이블에 레코드가 추가됨에 따라 SQLite는 자동으로 레코드에 숫자를 붙이고, 쿼리에서 이렇게 붙여진 레코드 숫자를 사용한다.\n%%sqlite survey.db\nselect rowid, * from Person;\n\n\n\n\n1\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\n2\n\n\npb\n\n\nFrank\n\n\nPabodie\n\n\n\n\n3\n\n\nlake\n\n\nAnderson\n\n\nLake\n\n\n\n\n4\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\n5\n\n\ndanforth\n\n\nFrank\n\n\nDanforth\n\n\n\n\n\n9.0.1 데이터 위생 (Data Hygiene)\n지금까지 조인이 어떻게 동작하는지 살펴봤으니, 왜 관계형 모델이 그렇게 유용한지 그리고 어떻게 가장 잘 사용할 수 있는지 살펴보자. 첫번째 규칙은 모든 값은 독립 요소로 분해될 수 없는 원자(atomic)적 속성을 지녀야 한다. 즉, 구별해서 작업하고자 하는 부분을 포함해서는 안된다. 하나의 칼럼에 전체 이름을 넣는 대신에 별도로 구별되는 칼럼에 이름과 성을 저장해서 이름 컴포넌트를 뽑아내는 부분 문자열 연산(substring operation)을 사용할 필요가 없다. 좀더 중요하게는, 별도로 이름을 두 부분으로 저장한다. 왜냐하면, 공백으로 쪼개는 것은 신뢰성이 약하다. “Eloise St. Cyr” 혹은 “Jan Mikkel Steubart” 같은 이름을 생각하면 쉽게 알 수 있다.\n두번째 규칙은 모든 레코드는 유일한 기본키를 가져야한다. 내재적인 의미가 전혀없는 일련번호가 될 수 있고, 레코드의 값중의 하나 (Person 테이블의 ident 필드), 혹은 Survey 테이블에서 심지어 모든 측정값을 유일하게 식별하는 (taken, person, quant) 삼중값의 조합도 될 수 있다.\n세번째 규칙은 불필요한 정보가 없어야 한다. 예를 들어, Site테이블을 제거하고 다음과 같이 Visited 테이블을 다시 작성할 수 있다.\n\n\n\n619\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\n\n\n622\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\n\n\n734\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\n\n\n735\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\n\n\n751\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\n\n\n752\n\n\n-47.15\n\n\n-126.72\n\n\nnull\n\n\n\n\n837\n\n\n-48.87\n\n\n-123.40\n\n\n1932-01-14\n\n\n\n\n844\n\n\n-49.85\n\n\n-128.57\n\n\n1932-03-22\n\n\n\n사실, 스프레드쉬트와 마찬가지로 각 행에 각 측정값에 관한 모든 정보를 기록하는 하나의 테이블을 사용할 수도 있다. 문제는 이와 같은 방식으로 조직된 데이터를 일관성있게 관리하는 것은 매우 어렵다. 만약 특정한 사이트의 특정한 방문 날짜가 잘못된다면, 데이터베이스에 다수의 레코드를 변경해야한다. 더 안좋은 것은 다른 사이트도 그 날짜에 방문되었기 때문에 어느 레코드를 변경할지 추정해야하는 것이다.\n네번째 규칙은 모든 값의 단위는 명시적으로 저장되어야한다. 예제 데이터베이스는 그렇지 못해서 문제다.\nRoerich의 염분치는 다른 사람의 측정치보다 수천배 크다. 하지만, 천단위 대신에 백만 단위를 사용하고 있는지 혹은 1932년 그 사이트에 염분에 이상 실제로 있었는지 알지못한다.\n한걸음 물러나서 생각하자, 데이터와 저장하는데 사용되는 도구는 공생관계다. 테이블과 조인은 데이터가 특정 방식으로 잘 조직되었다면 매우 효과적이다. 하지만, 만약 특정 형태로 되어 있다면 효과적으로 다룰 수 있는 도구가 있기 때문에 데이터를 그와 같은 방식으로 조직하기도 한다. 인류학자가 말했듯이, 도구는 도구를 만드는 손을 만든다. (the tool shapes the hand that shapes the tool)\n\n도전 과제\n\nDR-1 사이트의 모든 방사선 측정치를 출력하는 쿼리를 작성하세요.\n“Frank” 가 방문한 모든 사이트를 출력하는 쿼리를 작성하세요.\n다음 쿼리가 무슨 결과를 산출하는지 말로 기술하세요.\nselect Site.name from Site join Visited\non Site.lat&lt;-49.0 and Site.name=Visited.site and Visited.dated&gt;='1932-00-00';\n\n\n\n주요점\n\n모든 사실은 데이터베이스에서 정확하게 한번만 표현되어야 한다.\n조인은 한 테이블의 레코드와 다른 테이블의 레코드를 모두 조합한 결과를 출력한다.\n기본키는 테이블의 레코드를 유일하게 식별하는 필드값(혹은 필드의 집합)이다.\n외래키는 또 다른 테이블의 기본키가되는 필드값(혹은 필드의 집합)이다.\n테이블사이에 기본키와 외래키를 매칭해서 의미없는 레코드의 조합을 제거할 수 있다.\n조인을 좀더 단순하고 효율적으로 만들기 위해서 키(key)는 원자값(atomic value)이 되어야 한다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>데이터 조합하기 (Combining Data)</span>"
    ]
  },
  {
    "objectID": "18-create.html",
    "href": "18-create.html",
    "title": "10  데이터 생성과 변형(Creating and Modifying Data)",
    "section": "",
    "text": "목표\n\n테이블을 생성하는 쿼리를 작성한다.\n레코드를 삽입, 변형, 삭제하는 쿼리를 작성한다.\n\n\n지금까지 어떻게 데이터베이스에서 정보를 추출하는지만 살펴봤다. 왜냐하면, 정보를 추가하는 것보다 정보를 조회하는 것이 더 자주 있는 일이기도 하고, 다른 연산자는 쿼리가 이해되어야만 의미가 통하기 때문이다. 만약 데이터를 생성하고 변형하고자 한다면, 다른 두짝의 명령어를 공부할 필요가 있다.\n첫번째 짝은 create table과 drop table이다. 두 단어로 작성되지만, 사실 하나의 단일 명령어다. 첫번째 명령어는 새로운 테이블을 생성한다. 인자는 테이블 칼럼의 이름과 형식이다. 예를 들어, 다음 문장은 survey 데이터베이스에 테이블 4개를 생성한다.\ncreate table Person(ident text, personal text, family text);\ncreate table Site(name text, lat real, long real);\ncreate table Visited(ident integer, site text, dated text);\ncreate table Survey(taken integer, person text, quant real, reading real);\n다음 명령어를 사용하여 테이블 중의 하나를 제거할 수도 있다.\ndrop table Survey;\n데이블을 제거할 때 매우 주의하라. 대부분의 데이터베이이스는 변경사항을 되돌리는 기능을 제공하지만, 이러한 기능에 의존하지 않는 것이 더 낫다.\n다른 데이터베이스 시스템은 테이블 칼럼의 다른 데이터 형식도 지원하지만, 대부분은 다음을 다음을 제공한다.\n\n\n\ninteger\n\n\n부호있는 정수형\n\n\n\n\nreal\n\n\n부동 소수점 실수\n\n\n\n\ntext\n\n\n문자열\n\n\n\n\nblob\n\n\n이미지 같은 “이진 대형 개체”\n\n\n\n대부분의 데이터베이스는 불(boolean)과 날짜/시간 값도 지원한다. SQLite는 불값을 정수 0 과 1 을 사용하고 날짜/시간은 앞선(earlier) 학습방식으로 표현한다. 점점 더 많은 데이터베이스가 위도와 경도 같은 지리정보 데이터 형식도 지원한다. 특정 시스템이 무슨 기능을 제공하고 제공하지 않는지 그리고 어떤 이름을 다른 데이터 형식에 부여하는지를 계속 파악하는 것은 끝없는 시스템 이식성에 대한 골치거리다.\n테이블을 생성할 때, 칼럼에 몇가지 제약사항을 지정할 수 있다. 예를 들어, Survey 테이블에 대한 좀더 좋은 정의는 다음과 같이 될 것이다.\ncreate table Survey(\n    taken   integer not null, -- where reading taken\n    person  text,             -- may not know who took it\n    quant   real not null,    -- the quantity measured\n    reading real not null,    -- the actual reading\n    primary key(taken, quant),\n    foreign key(taken) references Visited(ident),\n    foreign key(person) references Person(ident)\n);\n다시 한번, 정확하게 무슨 제약사항이 이용가능하고 어떻게 호출되는지는 어떤 데이터베이스 관리자를 사용하는야에 달려있다.\n테이블이 생성되자마자, 다른 명령어 짝 insert와 delete를 사용하여 레코드를 추가하고 제거할 수 있다. insert 문의 가장 간단한 형식은 순서대로 값을 목록으로 나열하는 것이다.\ninsert into Site values('DR-1', -49.85, -128.57);\ninsert into Site values('DR-3', -47.15, -126.72);\ninsert into Site values('MSK-4', -48.87, -123.40);\n또한, 다른 테이블에서 직접 값을 테이블에 삽입할 수도 있다.\ncreate table JustLatLong(lat text, long text);\ninsert into JustLatLong select lat, long from site;\n레코드를 삭제하는 것은 약간 난이도가 있다. 왜냐하면, 데이터베이스가 내부적으로 일관성을 보장할 필요가 있기 때문이다. 만약 하나의 단독 테이블만 관심을 둔다면, 삭제하고자 하는 레코드와 매칭되는 where절과 delete문을 함께 사용한다. 예를 들어, Frank Danforth가 어떤 측정도 하지 않았다는 것을 인지하자마자, 다음과 같이 Person 테이블에서 Frank Danforth를 제거할 수 있다.\ndelete from Person where ident = \"danforth\";\n하지만 대신에 Anderson Lake를 실수로 제거했다면 어떨까요? Survey 테이블은 Anderson Lake이 수행한 7개의 측정 레코드를 담고 있지만, 이것은 결코 일어나지 말아야 된다. Survey.person은 Person 테이블에 외래키이고, 모든 쿼리는 전자의 모든 값을 매칭하는 후자의 행이 있을 거라고 가정한다.\n이러한 문제를 참조 무결성(referential integrity)이라고 부른다. 테이블 사이의 모든 참조는 항상 제대로 해결될 수 있도록 확인할 필요가 있다. 참조 무결성을 보증하는 한 방법은 기본키로 사용하는 레코드를 삭제하기 전에 외래키로 'lake'를 사용하는 모든 레코드를 삭제하는 것이다. 만약 데이터베이스 관리자가 이 기능을 지원한다면, 연쇄적인 삭제(cascading delete)를 사용해서 자동화할 수 있다. 하지만, 이 기법은 여기서 다루는 학습 영역밖이다.\n\n모든 것을 데이터베이스에 저장하는 대신 많은 응용프로그램은 하이브리드 저장 모델을 사용한다. 천체 이미지 같은 실제 데이터는 파일에 저장되는 반면에, 파일 이름, 변경된 날짜, 커버하는 하늘의 영역, 스펙트럼 특성, 등등 정보는 데이터베이스에 저장한다. 대부분의 음악 재생기(MP3 플레이어) 소프트웨어가 작성되는 방식이기도 하다. 응용프로그램 내부 데이터베이스는 MP3 파일을 기억하고 있지만, MP3 파일 자체는 디스크에 있다.\n\n\n도전 과제\n\nSurvey.person의 null인 모든 사용자를 문자열 'unknown'으로 대체하는 SQL문을 작성하세요.\n동료중의 한명이 Robert Olmstead가 측정한 온도 측정치를 포함하는 다음과 같은 형식의 CSV 파일을 보내왔다.\nTaken,Temp\n619,-21.5\n622,-15.5\nsurvey 데이터베이스에 레코드로 추가하려고 CSV 파일을 읽고 SQL insert문을 출력하는 작은 파이썬 프로그램을 작성하세요. Person 테이블에 Olmstead 항목을 추가할 필요가 있을 것이다. 반복적으로 프로그램을 테스트하려면, SQL insert or replace 문을 자세히 살펴볼 필요도 있다.\nSQLite는 SQL 표준이 아닌 몇개 관리 명령어가 있다. 그중의 하나가 .dump로 데이터베이스를 다시 생성하는데 필요한 SQL 명령문을 출력한다. 또다른 것은 .load로 .dump에서 생성된 파일을 읽어서 데이터베이스를 복원한다. 여러분의 동료중의 한명이 텍스트인 dump 파일을 버젼 제어 시스템에 저장하는 것이 데이터베이스 변경사항을 추적하고 관리하는 좋은 방법이라고 생각한다. 이러한 접근법의 장점과 단점은 무엇일까요? (힌트: 레코드는 어느 특정한 순서로 저장되지 않는다.)\n\n\n\n주요점\n\n데이터베이스 테이블은 테이블 이름과 필드의 이름과 특성을 명시하는 쿼리를 사용해서 생성된다.\n쿼리를 사용해서 레코드는 삽입, 갱신, 삭제될 수 있다.\n모든 레코드가 유일한 기본키를 가질 때 데이터를 변경하는 것이 더 간단하고 안전하다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>데이터 생성과 변형(Creating and Modifying Data)</span>"
    ]
  },
  {
    "objectID": "19-prog.html",
    "href": "19-prog.html",
    "title": "11  데이터베이스로 프로그래밍",
    "section": "",
    "text": "목표\n\nSQL 쿼리를 실행하는 짧은 프로그램을 작성한다.\nSQL 쿼리를 포함하는 프로그램의 실행을 추적한다.\n왜 대부분의 데이터베이스 응용프로그램이 SQL 보다 다른 범용 언어로 작성되는지 설명한다.\n\n\n마무리 하면서, 파이썬 같은 범용 프로그래밍 언어에서 데이터베이스를 어떻게 접근하는지 삺펴보자. 다른 언어도 거의 같은 모델을 사용한다. 라이브러리와 함수 이름이 다를지 모르지만, 개념은 동일한다.\nsurvey.db라는 이름의 파일에 저장된 SQLite 데이터베이스에서 위도와 경도를 선택하는 짧은 파이썬 프로그램이 다음에 있다.\nimport sqlite3\nconnection = sqlite3.connect(\"survey.db\")\ncursor = connection.cursor()\ncursor.execute(\"select site.lat, site.long from site;\")\nresults = cursor.fetchall()\nfor r in results:\n    print r\ncursor.close()\nconnection.close()\n\n(-49.85, -128.57)\n(-47.15, -126.72)\n(-48.87, -123.4)\n\n\nsqlite3 라이브러리를 가져오는 것부터 프로그램이 시작한다. 만약 MySQL, DB2 혹은 다른 데이터베이스에 접속한다면, 다른 라이브러리를 가져올 것이지만, 동일한 기능을 제공한다. 그래서 만약 다른 이 데이터베이스에서 저 데이터베이스로 바꾼다면 프로그램의 나머지 부분은 변경할 필요(적어도 그렇게 많지는 않다.)가 었다.\n2번째 행이 데이터베이스에 연결을 설정한다. SQLite를 사용하기 때문에, 명시하는데 필요한 전부는 데이터베이스 파일 이름이다. 다른 데이터베이스 시스템은 사용자명과 비밀번호를 또한 제공하도록 요구할지도 모른다. 3번째 행은 연결을 이용하여 커서(cursor)를 생성한다. 편집기의 커서처럼, 커서의 역할은 데이터베이스에 어느 위치에 있는지 추적하는 것이다.\n4번째 행에서 커서를 사용해서 사용자를 대신해서 데이터베이스에 쿼리 실행 요청을 한다. 쿼리는 SQL로 작성되고 문자열로 cursor.execute에 전달된다. SQL이 제대로 작성되어 있는지 확실히 하는 것이 사용자의 몫이다. 만약 제대로 작성이 되어 있지 않거나 실행될 때 뭔가 잘못되었다면, 데이터베이스는 오류를 보고한다.\n5번째 행에 cursor.fetchall 호출에 응답하여 데이터베이스가 쿼리 결과를 반환한다. 결과는 결과집합에 각 레코드마다 하나의 항목을 가진 리스트다. 만약 리스트(6번째 행)를 루프 반복을 돌려서 리스트 항목(7번째 행)을 출력하면, 각각은 각 필드에 하나의 요소를 가진 튜플(tuple)인 것을 알 수 있다.\n마지막으로, 8번째와 9번째 행은 커서와 데이터베이스 연결을 종료한다. 왜냐하면 데이터베이스는 한번에 열수 있는 제한된 숫자의 연결만 유지할 수 있기 때문이다. 하지만, 연결을 설정하는 것은 시간이 소요되어서, 단지 백만분의 수초 후에 다시 연결을 하고 또 다른 작업을 하려는 연결을 하고, 작업을 하고 나서 연결을 종료하는 것은 하지 말아야 한다.\n실제 응용프로그램에서 쿼리는 사용자가 제공하는 값에 달려있다. 예를 들어, 다음 함수는 사용자의 ID를 매개변수로 받아서 이름을 반환한다.\nQueries in real applications will often depend on values provided by users. For example, this function takes a user’s ID as a parameter and returns their name:\ndef get_name(database_file, person_ident):\n    query = \"select personal || ' ' || family from Person where ident='\" + person_ident + \"';\"\n\n    connection = sqlite3.connect(database_file)\n    cursor = connection.cursor()\n    cursor.execute(query)\n    results = cursor.fetchall()\n    cursor.close()\n    connection.close()\n\n    return results[0][0]\n\nprint \"full name for dyer:\", get_name('survey.db', 'dyer')\n\nfull name for dyer: William Dyer\n\n\n함수의 첫번째 행에 문자열 결함을 사용해서 사용자가 넘겨준 사용자 ID를 포함하는 쿼리를 완성한다. 단순하게 보일지 모르지만, 만약 누군가 다음 문자열을 입력값으로 준다면 무슨일이 일어날까?\ndyer'; drop table Survey; select '\n프로젝트 이름 뒤에는 쓰레기(garbage)처럼 보이지만, 매우 주의깊게 고른 쓰레기다. 만약 이 문자열을 쿼리에 삽입하면, 결과는 다음과 같다.\nselect personal || ' ' || family from Person where ident='dyer'; drop table Survey; select '';\n만약 쿼리를 실행하게 된다면, 데이터베이스에 있는 테이블 중의 하나를 삭제한다.\n이것을 SQL 주입 공격(SQL injection attack)이라고 부른다. SQL 주입공격은 수년에 걸쳐서 수천개의 프로그램을 공격하는데 사용되었다. 특히, 많은 웹사이트가 먼저 사려깊게 입력값을 점검하지 않고 사용자에게서 데이터를 입력받는 값을 쿼리로 바로 입력한다.\n악의를 가진 사용자가 다양한 많은 방식으로 쿼리에 명령어를 몰래 밀어넣으려고 한다. 이러한 위협을 다루는 가장 안전한 방식은 인용부호 같은 문자를 대체 상응값으로 대체하는 것이다. 그렇게 해서 안전하게 문자열 내부에 사용자가 입력한 무엇이든지 넣을 수 있다. 문자열로 문장을 작성하는 대신에 준비된 문장(prepared statement)를 사용해서 작업할 수 있다. 만약에 준비된 문장을 사용한다면, 예제 프로그램은 다음과 같다.\ndef get_name(database_file, person_ident):\n    query = \"select personal || ' ' || family from Person where ident=?;\"\n\n    connection = sqlite3.connect(database_file)\n    cursor = connection.cursor()\n    cursor.execute(query, [person_ident])\n    results = cursor.fetchall()\n    cursor.close()\n    connection.close()\n\n    return results[0][0]\n\nprint \"full name for dyer:\", get_name('survey.db', 'dyer')\n\nfull name for dyer: William Dyer\n\n\n주요 변경사항은 쿼리 문자열과 execute 호출에 있다. 쿼리 자체 형식을 만드는 대신에 쿼리 템플릿에 값을 삽입하고자 하는 곳에 물음표를 넣는다. execute를 호출할 때, 쿼리의 물음표 숫자만큼의 값을 담고 있는 리스트를 제공한다. 라이브러리는 입력값을 순서대로 물음표와 매칭하고 특수 문자를 별도 상응값으로 번역해서 안전하게 사용하게 된다.\n\n도전 과제\n\n10.0 에서 25.0 사이의 100,000개 난수를 가지는 레코드를 가지고, reading으로 불리는 단일 필드를 가지고, Pressure라는 단일 테이블을 가지고, original.db이라는 이름을 가지는 신규 데이터베이스를 파일에 생성하는 파이썬 프로그램을 작성하세요.\noriginal.db과 동일한 구조를 가지는 backup.db으로 불리는 새로운 데이터베이스를 생성하는 파이썬 프로그램을 작성하세요. backup.db는 original.db에서 backup.db로 20.0보다 큰 모든 값을 복사한 값을 담고 있다. 어느 것이 더 빠른가요? 쿼리의 값을 필터링하는 것 혹은 주기억장치에 모든 것을 읽어드리고 파이썬에서 필터링하는 것 중에서 선택하세요.\n\n\n\n주요점\n\n일반적으로 범용 언어로 데이터베이스 응용프로그램을 작성하고 SQL 쿼리를 프로그램에 내장한다.\n데이터베이스에 접속하기 위해서 프로그램은 접속하려는 데이터베이스 관리자에 특정된 라이브러리를 사용해야 한다.\n프로그램은 하나 혹은 그 이상의 연결을 단일 데이터베이스에 열고, 각각에 대해서 활성화된 하나 혹은 그 이상의 커서를 가진다.\n프로그램은 쿼리 결과를 배치모드로 혹은 한번에 모두 읽어들인다.",
    "crumbs": [
      "SQL",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>데이터베이스로 프로그래밍</span>"
    ]
  },
  {
    "objectID": "21-application.html#dvd-insight-rental",
    "href": "21-application.html#dvd-insight-rental",
    "title": "12  DVD 대여 데이터베이스",
    "section": "12.1 DVD DB 인사이트",
    "text": "12.1 DVD DB 인사이트\nDVT 대여 데이터베이스를 설치했다면 다음 단계로 다양한 SQL 쿼리문을 던져 뭔가 가치 있는 정보를 추출해야만 한다. 데이터 과학: “postgreSQL - DVD 대여 데이터베이스”에서 데이터베이스 설치와 접속에 대한 사항은 확인한다.\n\n12.1.1 DB 접속 헬로월드 6\n먼저 DBI::dbConnect()를 통해 접속하고 SQL 쿼리 헬로월드를 던져보자.\n\nlibrary(RPostgres)\n\ncon &lt;- dbConnect(RPostgres::Postgres(), dbname=\"dvd\", \n                 host=\"localhost\",\n                 port=\"5432\", \n                 user=\"postgres\", \n                 password=\"1234\")\n\nactor &lt;- dbGetQuery(con, \"SELECT * FROM actor LIMIT 5\")\n\nactor\n\n  actor_id first_name    last_name         last_update\n1        1   Penelope      Guiness 2013-05-26 14:47:57\n2        2       Nick     Wahlberg 2013-05-26 14:47:57\n3        3         Ed        Chase 2013-05-26 14:47:57\n4        4   Jennifer        Davis 2013-05-26 14:47:57\n5        5     Johnny Lollobrigida 2013-05-26 14:47:57\n\n\n12.1.2 이탈/잔존고객 구매금액\ncustomer 테이블에는 active 칼럼을 통해 잔존고객과 이탈고객을 파악할 수 있다. 이를 통해서 잔존고객과 이탈고객이 몇명이고 구매금액을 파악할 수 있다. 먼저 datamodelr 팩키지를 통해 해당 테이블을 뽑아내서 이를 시각화해보자.\n\nlibrary(tidyverse)\nlibrary(datamodelr)\n\npayment &lt;- tbl(con, \"payment\") %&gt;% collect()\ncustomer &lt;- tbl(con, \"customer\") %&gt;% collect()\n\npayment_customer_model &lt;- dm_from_data_frames(payment, customer)\n\npayment_customer_model &lt;- dm_add_references(\n  payment_customer_model,\n  customer$customer_id ==  payment$customer_id\n)\n\npayment_customer_graph &lt;- dm_create_graph(payment_customer_model, rankdir = \"LR\", col_attr = c(\"column\", \"type\"))\ndm_render_graph(payment_customer_graph)\n\n\n\n\n테이블 구조 시각화 - 구매금액\n\n\ncon을 통해 DVD 대여 데이터베이스에 접속이 이루어진 상태다. 이탈고객과 잔존고객별로 구매금액에 대한 평균, 최소, 최대, 총합계를 구하려면 두 테이블을 INNER JOIN으로 customer_id를 키값으로 합치고 나서 기술통계를 산출한다.\n\nsql_query &lt;- \n\"SELECT active, \n       COUNT(*) AS num_active, \n       MIN(amount) AS min_amt, \n       AVG(amount) AS avg_amt,\n       MAX(amount) AS max_amt, \n       SUM(amount) AS total_amt\nFROM payment AS p\nINNER JOIN customer AS c\n  ON p.customer_id = c.customer_id\nGROUP BY c.active;\"\n\ndbGetQuery(con, sql_query)\n\n  active num_active min_amt  avg_amt max_amt total_amt\n1      0        369    0.99 4.092981   11.99   1510.31\n2      1      14227    0.00 4.203397   11.99  59801.73\n\n\n12.1.3 쟝르별 평균 대여평점\n앞서와 마찬가지로 쟝르별 평균 대여평점을 계산할 수 있는 테이블을 쭉 뽑아본다. 이를 통해서 3개 테이블, 즉 category, film_category, film을 뽑아놓고 각 해당 키값을 사용하여 결합시킨다.\n\ncategory &lt;- tbl(con, \"category\") %&gt;% collect()\nfilm_category &lt;- tbl(con, \"film_category\") %&gt;% collect()\nfilm &lt;- tbl(con, \"film\") %&gt;% collect()\n\nrental_rating_model &lt;- dm_from_data_frames(category, film_category, film)\n\nrental_rating_model &lt;- dm_add_references(\n  rental_rating_model,\n  category$category_id == film_category$category_id,\n  film_category$film_id == film$film_id\n)\n\nrental_rating_graph &lt;- dm_create_graph(rental_rating_model, rankdir = \"LR\", col_attr = c(\"column\", \"type\"))\ndm_render_graph(rental_rating_graph)\n\n\n\n\n테이블 구조 시각화 - 쟝르별 대여평점\n\n\n먼저 film_category와 category를 결합시켜 영화(film)가 속한 쟝르(category)를 파악한다.\n\nrate_qry &lt;- \n\"SELECT * \nFROM category AS c\nINNER JOIN film_category AS fc\n  ON c.category_id = fc.category_id\nLIMIT 5;\"\n\ndbGetQuery(con, rate_qry)\n\n  category_id        name         last_update film_id category_id..5      last_update..6\n1           6 Documentary 2006-02-15 09:46:27       1              6 2006-02-15 10:07:09\n2          11      Horror 2006-02-15 09:46:27       2             11 2006-02-15 10:07:09\n3           6 Documentary 2006-02-15 09:46:27       3              6 2006-02-15 10:07:09\n4          11      Horror 2006-02-15 09:46:27       4             11 2006-02-15 10:07:09\n5           8      Family 2006-02-15 09:46:27       5              8 2006-02-15 10:07:09\n다음으로 film 테이블을 조인하여 rental_rate를 결합하고 쟝르(category) 별로 평균평점을 구하고 이를 ORDER BY ... DESC를 사용해서 내림차순으로 정렬한다.\n\nrate_qry &lt;- \n\"SELECT c.name,\n        AVG(rental_rate) AS avg_rental_rate\nFROM category AS c\nINNER JOIN film_category AS fc\n  ON c.category_id = fc.category_id \nINNER JOIN film AS f\n  ON fc.film_id = f.film_id\nGROUP BY c.category_id\nORDER BY avg_rental_rate DESC;\"\n\ndbGetQuery(con, rate_qry)\n\n          name avg_rental_rate\n1        Games        3.252295\n2       Travel        3.235614\n3       Sci-Fi        3.219508\n4       Comedy        3.162414\n5       Sports        3.125135\n6          New        3.116984\n7      Foreign        3.099589\n8       Horror        3.025714\n9        Drama        3.022258\n10       Music        2.950784\n11    Children        2.890000\n12   Animation        2.808182\n13      Family        2.758116\n14    Classics        2.744386\n15 Documentary        2.666471\n16      Action        2.646250\n\n\n12.1.4 Top 10 DVD 영화\n가장 많이 대여된 Top 10 DVD 영화를 찾아내기 위해서 이에 해당되는 연관 테이블을 검색하여 찾아낸다. film, inventory, rental 테이블을 특정하고 서로 연결시킬 수 있는 키값을 찾아 연결시킨다.\n\nfilm &lt;- tbl(con, \"film\") %&gt;% collect()\ninventory &lt;- tbl(con, \"inventory\") %&gt;% collect()\nrental &lt;- tbl(con, \"rental\") %&gt;% collect()\n\ntop_10_model &lt;- dm_from_data_frames(film, inventory, rental)\n\ntop_10_model &lt;- dm_add_references(\n  top_10_model,\n  film$film_id == inventory$film_id,\n  inventory$inventory_id == rental$inventory_id\n)\n\ntop_10_graph &lt;- dm_create_graph(top_10_model, rankdir = \"LR\", col_attr = c(\"column\", \"type\"))\ndm_render_graph(top_10_graph)\n\n\n\n\n테이블 구조 시각화 - Top 10 DVD 영화\n\n\nfilm → inventory → rental 테이블을 순차적으로 film_id, inventory_id를 키값으로 삼아 결합시킨다. 그리고 나서 가장 많이 대여된 영화를 찾기 위해서 COUNT() 함수로 개수하고 나서 이를 내림차순 정리한다.\n\ntop_query &lt;- \n\"SELECT f.title AS movie_title, \n        COUNT(f.title) AS num_rentals\nFROM film AS f\nINNER JOIN inventory AS i\n  ON f.film_id = i.film_id\nINNER JOIN rental AS r\n  ON i.inventory_id = r.inventory_id\nGROUP BY f.title\nORDER BY num_rentals DESC;\"\n\ndbGetQuery(con, top_query) %&gt;% \n  slice_max(n=10, order_by = num_rentals)\n\n           movie_title num_rentals\n1   Bucket Brotherhood          34\n2     Rocketeer Mother          33\n3       Juggler Hardly          32\n4  Ridgemont Submarine          32\n5        Scalawag Duck          32\n6       Grit Clockwork          32\n7       Forward Temple          32\n8       Timberland Sky          31\n9            Zorro Ark          31\n10        Robbers Joon          31\n11        Hobbit Alien          31\n12        Network Peak          31\n13       Apache Divine          31\n14     Rush Goodfellas          31\n15           Wife Turn          31\n16   Goodfellas Salute          31",
    "crumbs": [
      "챗GPT SQL",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DVD 대여 데이터베이스</span>"
    ]
  },
  {
    "objectID": "21-application.html#db-summary",
    "href": "21-application.html#db-summary",
    "title": "12  DVD 대여 데이터베이스",
    "section": "12.2 요약",
    "text": "12.2 요약\n이번 장은 파이썬에서 데이터베이스 사용 기본적인 개요에 대해 폭넓게 다루었다. 데이터를 저장하기 위해서 파이썬 딕셔너리나 일반적인 파일보다 데이터베이스를 사용하여 코드를 작성하는 것이 훨씬 복잡하다. 그래서, 만약 작성하는 응용프로그램이 실질적으로 데이터베이스 역량을 필요하지 않는다면 굳이 데이터베이스를 사용할 이유는 없다. 데이터베이스가 특히 유용한 상황은 (1) 큰 데이터셋에서 작은 임의적인 갱신이 많이 필요한 응용프로그램을 작성할 때 (2) 데이터가 너무 커서 딕셔너리에 담을 수 없고 반복적으로 정보를 검색할 때, (3) 한번 실행에서 다음 실행 때까지 데이터를 보관하고, 멈추고, 재시작하는데 매우 긴 실행 프로세스를 갖는 경우다.\n많은 응용프로그램 요구사항을 충족시키기 위해서 단일 테이블로 간단한 데이터베이스를 구축할 수 있다. 하지만, 대부분의 문제는 몇개의 테이블과 서로 다른 테이블간에 행이 연결된 관계를 요구한다. 테이블 사이 연결을 만들 때, 좀더 사려깊은 설계와 데이터베이스의 역량을 가장 잘 사용할 수 있는 데이터베이스 정규화 규칙을 따르는 것이 중요하다. 데이터베이스를 사용하는 주요 동기는 처리할 데이터의 양이 많기 때문에, 데이터를 효과적으로 모델링해서 프로그램이 가능하면 빠르게 실행되게 만드는 것이 중요하다.",
    "crumbs": [
      "챗GPT SQL",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>DVD 대여 데이터베이스</span>"
    ]
  }
]