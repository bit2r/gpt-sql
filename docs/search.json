[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "챗GPT 데이터베이스",
    "section": "",
    "text": "Preface\n거의 모든 사람이 스프레드쉬트(spreadsheet) 사용했고, 거의 모든 사람이 종국에는 한계에 맞닥뜨렸다. 데이터셋이 더욱 복잡할수록, 데이터를 걸러내고, 다른 행과 열 사이에 관계를 표현하거나, 결측값을 다루기가 점점 어려워진다.\n데이터베이스는 스프레드쉬트가 멈춘 곳에서 다시 시작한다. 만약 사용하고자 하는 것이 10여개의 숫자의 합이라면 데이터베이스는 사용하기가 간단하지는 않지만, 훨씬 큰 데이터셋에 훨씬 더 빨리 스프레드쉬트가 할 수없는 많은 것을 수행할 수 있다. 그리고, 설사 데이터베이스를 스스로 생성할 필요는 없지만, 데이터베이스가 어떻게 동작하는지 파악하는 것은 우리가 사용하는 수 많은 시스템이 왜 그와 같은 방식으로 동작하는지 그리고 왜 특정한 방식으로 데이터를 구조화하려고 하는지도 이해를 준다."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n1 + 1\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "00-setup.html#설치",
    "href": "00-setup.html#설치",
    "title": "1  SQLite 설치",
    "section": "1.1 설치",
    "text": "1.1 설치\n인터랙티브하게 다음 학습을 수행하기 위해서는 설치 방법에 언급된 SQLite 를 참조하여 설치하세요.\n그리고 , 여러분이 선택한 위치에 “software_carpentry_sql” 디렉토리를 생성하세요.예를 들어\n\n명령 라인 터미널 윈도우를 여세요.\n다음과 같이 타이핑한다.\n\nmkdir ~/swc/sql\n\n생성한 디렉토리로 현재 작업 디렉토리를 변경한다.\n\ncd ~/swc/sql\n\n1.1.1 github에서 “gen-survey-database.sql” 파일을 어떻게 다운로드 받을까요?\n“~/swc/sql” 디렉토리로 이동한 후에 그 디렉토리에서 github 사이트 (https://github.com/swcarpentry/bc/blob/master/novice/sql/gen-survey-database.sqlSQL) 에 위치한 SQL 파일(“gen-survey-database.sql”)을 다운로드한다.\n파일이 github 저장소 내에 위치하고 있어서, 전체 git 저장소(git repo)를 복제(cloning)하지 않고 단일 파일만 로컬로 가져온다. 이 목적을 달성하기 위해서, HTTP, HTTPS, FTP 프로토콜을 지원하는 명령-라인 웹크롤러(web-crawler) 소프트웨어 GNU Wget 혹은, 다양한 프로토콜을 사용하여 데이터를 전송하는데 사용되는 라이브러리이며 명령-라인 도구인 cURL을 사용한다. 두가지 도구 모두 크로스 플랫폼(cross platform)으로 다양한 운영체제를 지원한다.\nWget 혹은 cURL을 로컬에 설치한 후에, 터미널에서 다음 명령어를 실행한다.\n[Tip: 만약 cURL을 선호한다면, 다음 명령문에서 “wget”을 “curl -O”로 대체하세요.]\nmom@durga:~/swc/sql$ wget https://raw.githubusercontent.com/swcarpentry/bc/master/novice/sql/gen-survey-database.sql\n상기 명령문으로 Wget은 HTTP 요청을 생성해서 github 저장소의 “gen-survey-database.sql” 원 파일만 현재 작업 디렉토리로 가져온다. 성공적으로 완료되면 터미널은 다음 출력결과를 화면에 표시한다.\n--2014-09-02 18:31:43--  https://raw.githubusercontent.com/swcarpentry/bc/master/novice/sql/gen-survey-database.sql\nResolving raw.githubusercontent.com (raw.githubusercontent.com)... 103.245.222.133\nConnecting to raw.githubusercontent.com (raw.githubusercontent.com)|103.245.222.133|:443... connected.\nHTTP request sent, awaiting response... 200 OK\nLength: 3297 (3.2K) [text/plain]\nSaving to: ‘gen-survey-database.sql’\n\n100%[=========================================================================================================================&gt;] 3,297       --.-K/s   in 0.01s   \n\n2014-09-02 18:31:45 (264 KB/s) - ‘gen-survey-database.sql’ saved [3297/3297]\n이제 성공적으로 단일 SQL 파일을 가져와서, “survey.db” 데이터베이스를 생성하고 “gen-survey-database.sql” 에 저장된 지시방법에 따라서 데이터를 채워넣는다. 명령-라인 터미널에서 SQLite3 프로그램을 호출하기 위해서, 다음 명령문을 실행한다.\nsqlite3 survey.db &lt; gen-survey-database.sql\n\n\n1.1.2 SQLite DB 연결 및 설치 테스트\n생성된 데이터베이스에 연결하기 위해서, 데이터베이스를 생성한 디렉토리 안에서 SQLite를 시작한다. 그래서 “~/swc/sql” 디렉토리에서 다음과 같이 타이핑한다.\nsqlite3 survey.db\n“sqlite3 survey.db” 명령문이 데이터베이스를 열고 데이터베이스 명령-라인 프롬프트로 안내한다. SQLite에서 데이터베이스는 플랫 파일(flat file)로 명시적으로 열 필요가 있다. 그리고 나서 SQLite 시작되고 “sqlite”로 명령-라인 프롬프트로 다음과 같이 변경되어 표시된다.\n/novice/sql$ sqlite3 survey.db \nSQLite version 3.7.15.2 2013-01-09 11:53:05\nEnter \".help\" for instructions\nEnter SQL statements terminated with a \";\"\nsqlite&gt;  \n다음 출력결과가 보여주듯이 “.databases” 명령문으로 소속된 데이터베이스 이름과 파일 목록을 확인한다.\nsqlite&gt; .databases\nseq  name             file                                                      \n---  ---------------  ----------------------------------------------------------\n0    main             ~/novice/sql/survey.db \n다음과 같이 타이핑해서 필요한 “Person”, “Survey”, “Site” “Visited” 테이블이 존재하는 것을 확인한다.\n.tables\n그리고 “.table”의 출력결과는 다음과 같다.\nsqlite&gt; .tables\nPerson   Site     Survey   Visited\n이제, 설치를 완료해서 다음 학습으로 진행할 수 있다. 현재 명령-라인 SQLite 세션에서 다음 연습을 수행할 수 있다. IPython의 마술같은 방법 (%로 시작하는 각 명령문의 첫 행)은 IPython notebook에서만 동작하기 때문에, 터미널에서 SQLite를 사용하는 동안 생략할 수 있다. 만약 IPython notebook 사용을 선호하면 SQLite를 끝낼 수 있다.\n\n\n1.1.3 SQLite3 DB 명령-라인 인터페이스(CLI)를 어떻게 빠져나올까요?\nSQLite3를 빠져나오기 위해서, 다음과 같이 타이핑한다.\nsqlite&gt; .quit\n\n\n1.1.4 SQLite3 CLI 대신에 IPython notebook을 어떻게 사용할까요?\n만약 예제를 따라가는데 IPython notebook 사용을 선호한다면, IPython이 로컬 컴퓨터에 설치되었는지 점검하라. 만약 설치되어 있지 않다면, 설치 방법을 따르세요. 만약 IPython이 이미 로컬 컴퓨터에 설치되어 있다면 notebook을 열기 위해서 작업 폴더 “~/swc/sql” 내부에서 “ipython notebook”을 타이핑하세요.\n~/swc/sql$ ipython notebook\n상기 명령어가 IPython 커널을 구동해서 디폴트 브라우져에 인터랙티브 노트북을 화면에 표시해서 학습하면서 편집할 수 있게 한다. 다음 학습에 보여지는 명령문을 IPython notebook에서 수행할 수 있다. 훈련이 종료되면 변경사항을 간직하기 위해서 노트북 저장을 기억하세요."
  },
  {
    "objectID": "01-select.html",
    "href": "01-select.html",
    "title": "2  데이터 선택하기",
    "section": "",
    "text": "1920년 후반, 1930년 초반 William Dyer, Frank Pabodie,Valentina Roerich는 남태평양 도달불가능한 극(Pole of Inaccessibility)과 이어서 남극 대륙을 탐험했다. 2년 전에 이들의 탐험 기록이 Miskatonic 대학 창고 사물함에서 발견됐다. 기록을 스캔해서 OCR로 저장했고, 이제는 검색가능하고 분석이 용히한 방식으로 정보를 저장하고자 한다.\n기본적으로 3가지 선택 옵션(텍스트 파일, 스프레드쉬트, 데이터베이스)이 있다. 텍스트 파일은 생성하기 가장 쉽고 버젼 제어와 궁합이 맞지만, 검색과 분석 도구를 별도로 구축해야한다. 스프레드쉬트는 단순한 분석에는 적합하지만, 크고 복잡한 데이터셋을 매우 잘 다루지는 못한다. 그래서 데이터를 데이터베이스에 넣어서 어떻게 검색과 분석을 하는지 이번 학습에서 배울 것이다.\n\n목표\n\n테이블, 레코드, 필드의 차이점을 설명한다.\n데이터베이스와 데이터베이스 관리자의 차이를 설명한다.\n단독 테이블에서 특정 필드에 있는 모든 값을 선택하는 질의문(쿼리, query)를 작성한다.\n\n\n\n2.0.1 정의 몇가지\n관계형 데이터베이스(relational database)는 테이블(tables)로 정렬된 정보를 저장하고 다루는 방식이다. 각 테이블은 데이터를 기술하는 필드(fields)로도 알려진 열(column)과 데이터를 담고 있는 레코드(records)로 알려진 행(row)으로 구성된다.\n스프레드쉬트를 사용할 때, 이전 값에 기초하여 새로운 값을 계산할 때 공식을 셀(cell)에 넣어서 구한다. 데이터베이스를 사용할 때는 쿼리(queries, 질의)로 불리는 명령문을 데이터베이스 관리자(database manager)에게 보낸다. 데이터베이스 관리자는 사용자를 대신해서 데이터베이스를 다루는 프로그램이다. 데이터베이스 관리자는 쿼리가 명기하는 임의의 조회와 계산을 수행하고 다음 쿼리의 시작점으로 사용될 수 있는 테이블 형식으로 결과값을 반환한다.\n\n모든 데이터베이스 관리자(IBM DB2, PostgreSQL, MySQL, Microsoft Access, SQLite)는 서로 다른 고유한 방식으로 데이터를 저장해서 한곳에서 생성된 데이터베이스는 다른 곳의 데이터베이스에서 직접적으로 사용될 수 없다. 하지만, 모든 데이터베이스 관리자는 데이터를 다양한 형식으로 가져오기(import)와 내보내기(export)를 지원한다. 그래서 한 곳에서 다른 곳으로 정보를 이동하는 것이 가능하다.\n\n쿼리는 SQL로 불리는 언어로 작성된다. SQL 은 “Structured Query Language”(구조적 질의 언어)의 약자다. SQL은 데이터를 분석하고 다시 조합할 수 있는 수백개의 다른 방식을 제공한다. 학습에서 일부를 살펴볼 것이지만, 이 일부가 과학자가 수행하는 일의 대부분을 처리할 것이다.\n다음 테이블은 예제로 사용할 데이터베이스를 보여준다.\n\n\n\nPerson: 판독한 사람.\n\n\n\nident\n\n\npersonal\n\n\nfamily\n\n\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\npb\n\n\nFrank\n\n\nPabodie\n\n\n\n\nlake\n\n\nAnderson\n\n\nLake\n\n\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\ndanforth\n\n\nFrank\n\n\nDanforth\n\n\n\nSite: 판독한 장소.\n\n\n\nname\n\n\nlat\n\n\nlong\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n\nVisited: 특정 사이트에서 판독한 시점.\n\n\n\nident\n\n\nsite\n\n\ndated\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n752\n\n\nDR-3\n\n\n \n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n\nSurvey: 실제 판독.\n\n\n\ntaken\n\n\nperson\n\n\nquant\n\n\nreading\n\n\n\n\n619\n\n\ndyer\n\n\nrad\n\n\n9.82\n\n\n\n\n619\n\n\ndyer\n\n\nsal\n\n\n0.13\n\n\n\n\n622\n\n\ndyer\n\n\nrad\n\n\n7.8\n\n\n\n\n622\n\n\ndyer\n\n\nsal\n\n\n0.09\n\n\n\n\n734\n\n\npb\n\n\nrad\n\n\n8.41\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n734\n\n\npb\n\n\ntemp\n\n\n-21.5\n\n\n\n\n735\n\n\npb\n\n\nrad\n\n\n7.22\n\n\n\n\n735\n\n\n \n\n\nsal\n\n\n0.06\n\n\n\n\n735\n\n\n \n\n\ntemp\n\n\n-26.0\n\n\n\n\n751\n\n\npb\n\n\nrad\n\n\n4.35\n\n\n\n\n751\n\n\npb\n\n\ntemp\n\n\n-18.5\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nrad\n\n\n2.19\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nlake\n\n\ntemp\n\n\n-16.0\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nrad\n\n\n1.46\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\n\n\n3개 항목 (Visited 테이블에서 1개, Survey 테이블에서 2개) 은 붉은색으로 표기한 것을 주목하라. 왜냐하면 어떠한 값도 담고 있지 않아서 그렇다. 뒤에 결측값(missing)을 다시 다룰 것이다. 지금으로서는 과학자의 이름을 화면에 표시하는 SQL을 작성하자. SQL select 문을 사용해서 원하는 칼럼이름과 원하는 테이블이름을 준다. 쿼리와 결과는 다음과 같다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect family, personal from Person;\n\n\n\n\nDyer\n\n\nWilliam\n\n\n\n\nPabodie\n\n\nFrank\n\n\n\n\nLake\n\n\nAnderson\n\n\n\n\nRoerich\n\n\nValentina\n\n\n\n\nDanforth\n\n\nFrank\n\n\n\n\n쿼리 끝에 세미콜론(;)은 쿼리가 완료되어 실행준비 되었다고 데이터베이스 관리자에게 알려준다. 명령문과 칼럼 이름을 모두 소문자로 작성했고, 테이블 이름은 타이틀 케이스(Title Case, 단어의 첫 문자를 대문자로 표기)로 작성했다. 하지만 그렇게 반듯이 할 필요는 없다. 아래 예제가 보여주듯이, SQL은 대소문자 구분하지 않는다. (case insensitive)\n%%sqlite survey.db\nSeLeCt FaMiLy, PeRsOnAl FrOm PeRsOn;\n\n\n\n\nDyer\n\n\nWilliam\n\n\n\n\nPabodie\n\n\nFrank\n\n\n\n\nLake\n\n\nAnderson\n\n\n\n\nRoerich\n\n\nValentina\n\n\n\n\nDanforth\n\n\nFrank\n\n\n\n\n모두 소문자, 타이틀 케이스, 소문자 낙타 대문자(Lower Camel Case)를 선택하든지 관계없이 일관성을 가져라. 랜덤 대문자를 추가적으로 인지하지 않더라고 복잡한 쿼리는 충분히 그 자체로 이해하기 어렵다.\n쿼리로 돌아가서, 데이터베이스 테이블의 행과 열이 특정한 순서로 저장되지 않는다는 것을 이해하는 것이 중요하다. 어떤 순서로 항상 표시되지만, 다양한 방식으로 제어할 수 있다. 예를 들어, 쿼리를 다음과 같이 작성해서 칼럼을 교환할 수 있다.\n%%sqlite survey.db\nselect personal, family from Person;\n\n\n\n\nWilliam\n\n\nDyer\n\n\n\n\nFrank\n\n\nPabodie\n\n\n\n\nAnderson\n\n\nLake\n\n\n\n\nValentina\n\n\nRoerich\n\n\n\n\nFrank\n\n\nDanforth\n\n\n\n\n혹은 심지어 칼럼을 반복할 수도 있다.\n%%sqlite survey.db\nselect ident, ident, ident from Person;\n\n\n\n\ndyer\n\n\ndyer\n\n\ndyer\n\n\n\n\npb\n\n\npb\n\n\npb\n\n\n\n\nlake\n\n\nlake\n\n\nlake\n\n\n\n\nroe\n\n\nroe\n\n\nroe\n\n\n\n\ndanforth\n\n\ndanforth\n\n\ndanforth\n\n\n\n\n손쉬운 방법으로, *을 사용해서 테이블의 모든 칼럼을 선택할 수도 있다.\n%%sqlite survey.db\nselect * from Person;\n\n\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\npb\n\n\nFrank\n\n\nPabodie\n\n\n\n\nlake\n\n\nAnderson\n\n\nLake\n\n\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\ndanforth\n\n\nFrank\n\n\nDanforth\n\n\n\n\n\n도전 과제\n\nSite 테이블에서 사이트 이름만 선택하는 쿼리를 작성하세요.\n많은 사람들이 쿼리를 다음과 같은 형식으로 작성한다.\nSELECT personal, family FROM person;\n혹은 다음과 같이도 작성한다.\nselect Personal, Family from PERSON;\n읽기 쉽기 쉬운 스타일은 어느 것인가요? 이유는 무엇일까요?\n\n\n\n주요점\n\n관계형 데이터베이스는 정보를 테이블로 저장한다. 고정된 숫자의 칼럼과 변하기 쉬운 숫자의 레코드로 구성된다.\n\n데이터베이스 관리자는 데이터베이스에 저장된 정보를 다루는 프로그램이다.\n데이터베이스에서 정보를 추출하는데 SQL이라고 불리는 특화된 언어로 쿼리를 작성한다.\nSQL은 대소문자를 구별하지 않는다."
  },
  {
    "objectID": "02-sort-dup.html",
    "href": "02-sort-dup.html",
    "title": "3  정렬하고 중복 제거하기",
    "section": "",
    "text": "목표\n\n특정 순서로 결과를 표시하는 쿼리를 작성한다.\n데이터에서 중복값을 제거하는 쿼리를 작성한다.\n\n\n데이터는 종종 잉여가 있어서, 쿼리도 종종 과잉 정보를 반환한다. 예를 들어, survey 테이블에서 측정된 수량 정보를 선택하면, 다음을 얻게된다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect quant from Survey;\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\ntemp\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\ntemp\n\n\n\n\nrad\n\n\n\n\ntemp\n\n\n\n\nsal\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\ntemp\n\n\n\n\nsal\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\nsal\n\n\n\n\nrad\n\n\n\n\n결과를 좀더 읽을 수 있게 만들기 위해서 쿼리에 distinct 키워드를 추가해서 중복된 출력을 제거한다.\n%%sqlite survey.db\nselect distinct quant from Survey;\n\n\n\n\nrad\n\n\n\n\nsal\n\n\n\n\ntemp\n\n\n\n\n하나 이상의 칼럼(예를 들어 survey 사이트 ID와 측정된 수량)을 선택한다면, 별개로 구별된 값의 쌍이 반환된다.\n%%sqlite survey.db\nselect distinct taken, quant from Survey;\n\n\n\n\n619\n\n\nrad\n\n\n\n\n619\n\n\nsal\n\n\n\n\n622\n\n\nrad\n\n\n\n\n622\n\n\nsal\n\n\n\n\n734\n\n\nrad\n\n\n\n\n734\n\n\nsal\n\n\n\n\n734\n\n\ntemp\n\n\n\n\n735\n\n\nrad\n\n\n\n\n735\n\n\nsal\n\n\n\n\n735\n\n\ntemp\n\n\n\n\n751\n\n\nrad\n\n\n\n\n751\n\n\ntemp\n\n\n\n\n751\n\n\nsal\n\n\n\n\n752\n\n\nrad\n\n\n\n\n752\n\n\nsal\n\n\n\n\n752\n\n\ntemp\n\n\n\n\n837\n\n\nrad\n\n\n\n\n837\n\n\nsal\n\n\n\n\n844\n\n\nrad\n\n\n\n\n양쪽 경우에 설사 데이터베이스 내에서 서로 인접하지 않더라도 모두 중복이 제거된 것을 주목하세요. 다시 한번, 행은 실제로 정렬되지는 않았다는 것을 기억하세요. 단지 정렬된 것으로 화면에 출력된다.\n\n도전 과제\n\nSite 테이블에서 별개로 구별되는 날짜를 선택하는 쿼리를 작성하세요.\n\n앞서 언급했듯이, 데이터베이스 레코드는 특별한 순서로 저장되지 않는다. 이것이 의미하는 바는 쿼리 결과가 반드시 정렬되어 있지 않다는 것이다. 설사 정렬이 되어 있더라도, 종종 다른 방식으로 정렬하고 싶을 것이다. 예를 들어 과학자의 이름 대신에 프로젝트 이름으로 정렬할 수도 있다. SQL에서 쿼리에 order by 절을 추가해서 간단하게 구현할 수 있다.\n%%sqlite survey.db\nselect * from Person order by ident;\n\n\n\n\ndanforth\n\n\nFrank\n\n\nDanforth\n\n\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\nlake\n\n\nAnderson\n\n\nLake\n\n\n\n\npb\n\n\nFrank\n\n\nPabodie\n\n\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\n디폴트로, 결과는 오름차순으로 정렬되어야 한다. (즉, 가장 적은 값에서 가장 큰 값 순으로 정렬된다.) desc (“descending”)를 사용해서 역순으로도 정렬할 수 있다.\n%%sqlite survey.db\nselect * from person order by ident desc;\n\n\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\npb\n\n\nFrank\n\n\nPabodie\n\n\n\n\nlake\n\n\nAnderson\n\n\nLake\n\n\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\ndanforth\n\n\nFrank\n\n\nDanforth\n\n\n\n\n(그리고, desc 대신에 asc를 사용해서 오름차순으로 정렬하고 있다는 것을 명시적으로 표현할 수도 있다.)\n한번에 여러 필드를 정렬할 수도 있다. 예를 들어, 다음 쿼리는 taken 필드를 오름차순으로 그리고 동일 그룹의 taken 값 내에서는 person으로 내림차순으로 결과를 정렬한다.\n%%sqlite survey.db\nselect taken, person from Survey order by taken asc, person desc;\n\n\n\n\n619\n\n\ndyer\n\n\n\n\n619\n\n\ndyer\n\n\n\n\n622\n\n\ndyer\n\n\n\n\n622\n\n\ndyer\n\n\n\n\n734\n\n\npb\n\n\n\n\n734\n\n\npb\n\n\n\n\n734\n\n\nlake\n\n\n\n\n735\n\n\npb\n\n\n\n\n735\n\n\nNone\n\n\n\n\n735\n\n\nNone\n\n\n\n\n751\n\n\npb\n\n\n\n\n751\n\n\npb\n\n\n\n\n751\n\n\nlake\n\n\n\n\n752\n\n\nroe\n\n\n\n\n752\n\n\nlake\n\n\n\n\n752\n\n\nlake\n\n\n\n\n752\n\n\nlake\n\n\n\n\n837\n\n\nroe\n\n\n\n\n837\n\n\nlake\n\n\n\n\n837\n\n\nlake\n\n\n\n\n844\n\n\nroe\n\n\n\n\n만약 중복을 제거한다면 이해하기가 더 쉽다.\n%%sqlite survey.db\nselect distinct taken, person from Survey order by taken asc, person desc;\n\n\n\n\n619\n\n\ndyer\n\n\n\n\n622\n\n\ndyer\n\n\n\n\n734\n\n\npb\n\n\n\n\n734\n\n\nlake\n\n\n\n\n735\n\n\npb\n\n\n\n\n735\n\n\nNone\n\n\n\n\n751\n\n\npb\n\n\n\n\n751\n\n\nlake\n\n\n\n\n752\n\n\nroe\n\n\n\n\n752\n\n\nlake\n\n\n\n\n837\n\n\nroe\n\n\n\n\n837\n\n\nlake\n\n\n\n\n844\n\n\nroe\n\n\n\n\n\n\n도전 과제\n\nVisited 테이블에서 별개로 구별되는 날짜를 반환하는 쿼리를 작성하세요.\n성(family name)으로 정렬된 Person 테이블에 과학자의 성명 전부를 화면에 출력하는 쿼리를 작성하세요.\n\n\n\n주요점\n\n데이터베이스 테이블의 레코드는 본질적으로 정렬되지 않는다. 만약 특정 순서로 정렬하여 표시하려면, 명시적으로 정렬을 명기하여야 한다.\n데이터베이스의 값이 유일(unique)함을 보장하지는 않는다. 만약 중복을 제거하고자 한다면, 명시적으로 유일함을 명기하여야 한다."
  },
  {
    "objectID": "03-filter.html",
    "href": "03-filter.html",
    "title": "4  필터링 (Filtering)",
    "section": "",
    "text": "목표\n\n사용자가 정의한 조건을 만족하는 레코드를 선택하는 쿼리를 작성한다.\n쿼리 절이 실행되는 순서를 설명한다.\n\n\n데이터베이스의 가장 강력한 기능중 하나는 데이터를 필터(filter)하는 능력이다. 즉, 특정 기준에 맞는 레코드만 선택한다. 예를 들어, 특정 사이트를 언제 방문했는지 확인한다고 가정하자. 쿼리에 where 절을 사용해서 Visited 테이블로부터 레코드를 뽑아낼 수 있다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect * from Visited where site='DR-1';\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n데이터베이스 관리자는 두 단계로 나누어 쿼리를 실행한다. 첫번째로, where 절을 만족하는 것이 있는지 확인하기 위해서 Visited 테이블의 각 행을 점검한다. 그리고 나서 무슨 칼럼을 표시할지 결정하기 위해서 select 키워드 다음에 있는 칼럼 이름을 사용한다.\n이러한 처리 순서가 의미하는 바는 화면에 표시되지 않는 칼럼 값에 기반해서도 where 절을 사용해서 레코드를 필터링할 수 있다는 것이다.\n%%sqlite survey.db\nselect ident from Visited where site='DR-1';\n\n\n\n\n619\n\n\n\n\n622\n\n\n\n\n844\n\n\n\n\n\n데이터를 필터링하는데 불 연산자(Boolean Operators)를 사용할 수 있다. 예를 들어, 1930년 이후로 DR-1 사이트에서 수집된 모든 정보를 요청할 수도 있다.\n%%sqlite survey.db\nselect * from Visited where (site='DR-1') and (dated&gt;='1930-00-00');\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n(각 테스트 주위의 괄호는 엄밀히 말해 필요하지는 않지만 쿼리를 좀더 읽기 쉽게 한다.)\n\n대부분의 데이터베이스 관리자는 날짜에 대한 특별한 데이터 형식을 가진다. 사실 많이 있지만 두가지 형식으로 볼 수 있다. 날짜 데이터 형식의 하나는 “May 31, 1971”와 같은 것이고, 다른 하나는 “31 days” 같은 기간에 대한 것이다. SQLite는 구분하지는 않는다. 대신에 SQLite는 날짜를 텍스트 (ISO-8601 표준 형식 “YYYY-MM-DD HH:MM:SS.SSSS”), 혹은 실수 (November 24, 4714 BCE 이후 지나간 일수), 혹은 정수 (1970년 1월 1일 자정 이후 초)로만 저장한다. 만약 복잡하게 들린다면, 그럴수도 있다 하지만 스웨덴의 역사적인 날짜(historical dates in Sweden)를 이해하는 것만큼 복잡하는지는 않다.\n\nLake 혹은 Roerich가 무슨 측정을 했는지 알아내고자 한다면, or를 사용하여 이름에 테스트를 조합할 수 있다.\n%%sqlite survey.db\nselect * from Survey where person='lake' or person='roe';\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nrad\n\n\n2.19\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nlake\n\n\ntemp\n\n\n-16.0\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nrad\n\n\n1.46\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\n다른 방식으로, in을 사용하여 특정 집합에 값이 있는지 확인할 수 있다.\n%%sqlite survey.db\nselect * from Survey where person in ('lake', 'roe');\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nrad\n\n\n2.19\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nlake\n\n\ntemp\n\n\n-16.0\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nrad\n\n\n1.46\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\nand와 or를 조합할 수는 있지만, 어느 연산자가 먼저 수행되는지 주의할 필요가 있다. 만약 괄호를 사용하지 않는다면, 다음을 얻게 된다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and person='lake' or person='roe';\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n844\n\n\nroe\n\n\nrad\n\n\n11.25\n\n\n\n\n상기 결과는 Lake가 측정한 염분량과 Roerich가 측정한 임의 측정값이다. 대신에 아마도 다음과 같은 결과를 얻고자 했을 것이다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and (person='lake' or person='roe');\n\n\n\n\n734\n\n\nlake\n\n\nsal\n\n\n0.05\n\n\n\n\n751\n\n\nlake\n\n\nsal\n\n\n0.1\n\n\n\n\n752\n\n\nlake\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nlake\n\n\nsal\n\n\n0.21\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n마지막으로 distinct와 where를 사용하여 두번째 수준의 필터링을 한다.\n%%sqlite survey.db\nselect distinct person, quant from Survey where person='lake' or person='roe';\n\n\n\n\nlake\n\n\nsal\n\n\n\n\nlake\n\n\nrad\n\n\n\n\nlake\n\n\ntemp\n\n\n\n\nroe\n\n\nsal\n\n\n\n\nroe\n\n\nrad\n\n\n\n\n하지만, 기억하라. distinct는 처리될 때 선택된 칼럼에 표시되는 값에만 적용되고 전체 행에는 적용되지 않는다.\n\n방금전까지 수행하는 것은 대부분의 사람들이 어떻게 SQL 쿼리를 증가시키는지 살펴봤다. 의도한 것의 일부를 수행하는 단순한 것에서부터 시작했다. 그리고 절을 하나씩 하나씩 추가하면서 효과를 테스트했다. 좋은 전략이다. 사실 복잡한 쿼리를 작성할 때, 종종 유일한 전략이다. 하지만 이 전략은 빠른 회전(turnaround)시간에 달려있고 사용자에게는 정답을 얻게되면 인지하는 것에 달려있다. 빠른 회전시간을 달성하는 최선의 방법은 임시 데이터베이스에 데이터의 일부를 저장하고 쿼리를 실행하거나 혹은 합성된 레코드로 작은 데이터베이스를 채워놓고 작업을 하는 것이다. 예를 들어, 2천만 호주사람의 실제 데이터베이스에 쿼리를 작업하지 말고, 1만명 샘플을 뽑아 쿼리를 돌리거나 작은 프로그램을 작성해서 랜덤으로 혹은 그럴듯한 1만명 레코드를 생성해서 사용한다.\n\n\n도전 과제\n\n극에서 30&deg보다 고위도에 위치한 모든 사이트를 선택하고자 한다고 가정하자. 작성한 첫번째 쿼리는 다음과 같다.\nselect * from Site where (lat &gt; -60) or (lat &lt; 60);\n왜 이 쿼리가 잘못된 것인지 설명하세요. 그리고 쿼리를 다시 작성해서 올바르게 동작하게 만드세요.\n정규화된 염분 수치는 0.0에서 1.0 사이에 있어야 한다. 상기 범위 밖에 있는 염분수치를 가진 모든 레코드를 Survey 테이블에서 선택하는 쿼리를 작성하세요.\n만약 명명된 칼럼의 값이 주어진 패턴과 일치한다면 SQL 테스트 *column-name* like *pattern*은 참이다. “0 혹은 그 이상의 문자와 매칭”된다는 것을 의미하기 위해서 ’%’문자를 패턴에 임의 숫자 횟수에 사용한다.\n\n\n\n표현식\n\n\n값\n\n\n\n\n‘a’ like ‘a’\n\n\nTrue\n\n\n\n\n‘a’ like ‘%a’\n\n\nTrue\n\n\n\n\n‘b’ like ‘%a’\n\n\nFalse\n\n\n\n\n‘alpha’ like ‘a%’\n\n\nTrue\n\n\n\n\n‘alpha’ like ‘a%p%’\n\n\nTrue\n\n\n\n표현식 *column-name* not like *pattern*은 테스트를 거꾸로 한다. like를 사용하여 사이트에서 ’DR-something’으로 라벨이 붙지 않은 모든 레코드를 Visited에서 찾는 쿼리를 작성하세요.\n\n\n\n주요점\n\nwhere를 사용해서 불 조건(Boolean conditions)에 따라 레코드를 필터링한다.\n필터링이 전체 레코드에 적용되어서, 조건을 실제로 표시되지 않는 필드에 사용할 수 있다."
  },
  {
    "objectID": "04-calc.html",
    "href": "04-calc.html",
    "title": "5  새로운 값 계산하기",
    "section": "",
    "text": "목표\n\n각 선택된 레코드에 대해 새로운 값을 계산하는 쿼리를 작성한다.\n\n\n주의깊이 탐험 기록을 다시 정독한 뒤에, 탐험대가 보고한 방사선 측정치가 5%만큼 상향되어 수정될 필요가 있다는 것을 깨달았다. 저장된 데이터를 변형하기 보다는 쿼리의 일부분으로서 즉석에서 계산을 수행할 수 있다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect 1.05 * reading from Survey where quant='rad';\n\n\n\n\n10.311\n\n\n\n\n8.19\n\n\n\n\n8.8305\n\n\n\n\n7.581\n\n\n\n\n4.5675\n\n\n\n\n2.2995\n\n\n\n\n1.533\n\n\n\n\n11.8125\n\n\n\n\n쿼리를 실행하면, 표현식 1.05 * reading이 각 행마다 평가된다. 표현식에는 임의의 필드, 통상 많이 사용되는 연산자, 그리고 다양한 함수를 사용한다. (정확하게는 어느 데이터베이스 관리자를 사용되느냐에 따라 의존성을 띄게된다.) 예를 들어, 온도 측정치를 화씨에서 섭씨로 소수점 아래 두자리에서 반올림하여 변환할 수 있다.\n%%sqlite survey.db\nselect taken, round(5*(reading-32)/9, 2) from Survey where quant='temp';\n\n\n\n\n734\n\n\n-29.72\n\n\n\n\n735\n\n\n-32.22\n\n\n\n\n751\n\n\n-28.06\n\n\n\n\n752\n\n\n-26.67\n\n\n\n\n다른 필드의 값을 조합할 수도 있다. 예를 들어, 문자열 접합 연산자 (string concatenation operator, ||)를 사용한다.\n%%sqlite survey.db\nselect personal || ' ' || family from Person;\n\n\n\n\nWilliam Dyer\n\n\n\n\nFrank Pabodie\n\n\n\n\nAnderson Lake\n\n\n\n\nValentina Roerich\n\n\n\n\nFrank Danforth\n\n\n\n\n\nfirst와 last 대신에 필드 이름으로 personal과 family를 사용하는 것이 이상해 보일지 모른다. 하지만, 문화적 차이를 다루기 위한 필요한 첫번째 단계다. 예를 들어, 다음 규칙을 고려해보자.\n\n\n\n\n성명 전부(Full Name)\n\n\n알파벳 순서\n\n\n이유\n\n\n\n\nLiu Xiaobo\n\n\nLiu\n\n\n중국 성이 이름보다 먼저 온다.\n\n\n\n\nLeonardo da Vinci\n\n\nLeonardo\n\n\n“da Vinci” 는 “from Vinci”를 뜻한다.\n\n\n\n\nCatherine de Medici\n\n\nMedici\n\n\n성(family name)\n\n\n\n\nJean de La Fontaine\n\n\nLa Fontaine\n\n\n성(family name)이 “La Fontaine”이다.\n\n\n\n\nJuan Ponce de Leon\n\n\nPonce de Leon\n\n\n전체 성(full family name)이 “Ponce de Leon”이다.\n\n\n\n\nGabriel Garcia Marquez\n\n\nGarcia Marquez\n\n\n이중으로 된 스페인 성(surnames)\n\n\n\n\nWernher von Braun\n\n\nvon or Braun\n\n\n독일 혹은 미국에 있는냐에 따라 달라짐\n\n\n\n\nElizabeth Alexandra May Windsor\n\n\nElizabeth\n\n\n군주가 통치하는 이름에 따라 알파벳순으로 정렬\n\n\n\n\nThomas a Beckett\n\n\nThomas\n\n\n시성된(canonized) 이름에 따라 성인이름 사용\n\n\n\n\n분명하게, 심지어 두부분 “personal”과 “family”으로 나누는 것도 충분하지 않다.\n\n\n도전 과제\n\n좀더 조사한 뒤에, Valentina Roerich는 염도를 퍼센티지(%)로 작성한 것을 알게되었다. Survey 테이블에서 값을 100으로 나누어서 모든 염도 측정치를 반환하는 쿼리를 작성하세요.\nunion 연산자는 두 쿼리의 결과를 조합한다.\n\n%%sqlite survey.db\nselect * from Person where ident='dyer' union select * from Person where ident='roe';\n\n\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\nunion을 사용하여 앞선 도전과제에서 기술되어 수정된 Roerich가 측정한, Roerich만 측정한 염도 측정치의 통합 리스트를 생성하세요. 출력결과는 다음과 같아야 한다.\n\n\n\n619\n\n\n0.13\n\n\n\n\n622\n\n\n0.09\n\n\n\n\n734\n\n\n0.05\n\n\n\n\n751\n\n\n0.1\n\n\n\n\n752\n\n\n0.09\n\n\n\n\n752\n\n\n0.416\n\n\n\n\n837\n\n\n0.21\n\n\n\n\n837\n\n\n0.225\n\n\n\n\nVisited 테이블에 사이트 식별자는 ’-’으로 구분되는 두 부분으로 구성되어 있다.\n\n%%sqlite survey.db\nselect distinct site from Visited;\n\n\n\n\nDR-1\n\n\n\n\nDR-3\n\n\n\n\nMSK-4\n\n\n\n\n몇몇 주요 사이트 식별자는 두 문자길이를 가지고 몇몇은 3문자길이를 가진다. “in string” 함수 instr(X, Y)은 X 문자열에 문자열 Y가 첫번째 출현의 1-기반 인덱스를 반환하거나 Y가 X에 존재하지 않으면 0 을 반환한다. 부분 문자열 함수 substr(X, I)은 인덱스 I에서 시작하는 문자열 X의 부분문자열을 반환한다. 상기 두 함수를 사용해서 유일한 주요 사이트 식별자를 생성하세요. (이 데이터에 대해서 작업된 리스트는 “DR”과 “MSK”만 포함해야 한다.)\n\n\n주요점\n\nSQL은 쿼리의 일부로서 레코드의 값을 사용한 계산을 수행한다."
  },
  {
    "objectID": "05-null.html",
    "href": "05-null.html",
    "title": "6  결측 데이터 (Missing Data)",
    "section": "",
    "text": "목표\n\n데이터베이스가 어떻게 결측 정보를 표현하는지 설명한다.\n결측 정보를 다룰 때, 3개 값을 가진 로직(three-valued logic) 데이터베이스 사용을 설명한다.\n결측 정보를 올바르게 처리하는 쿼리를 작성한다.\n\n\n현실 세계 데이터는 결코 완전하지 않고 구멍은 항상 있다. null로 불리는 특별한 값을 사용하여 데이터베이스는 구멍을 표현한다. null는 0, False, 혹은 빈 문자열도 아니다.”아무것도 없음(nothing here)“을 의미하는 특별한 값이다. null을 다루는 것은 약간 특별한 기교와 신중한 생각을 요구한다.\n시작으로 Visited 테이블을 살펴보자. 레코드가 8개 있지만 #752은 날짜가 없다. 혹은 더 정확히 말하면 날짜가 null이다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect * from Visited;\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nNull 다른 값과는 다르게 동작한다. 만약 1930년 이전 레코드를 선택한다면,\n%%sqlite survey.db\nselect * from Visited where dated&lt;'1930-00-00';\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n결과 2개를 얻게 되고, 만약 1930년 동안 혹은 이후 레코드를 선택한다면,\n%%sqlite survey.db\nselect * from Visited where dated&gt;='1930-00-00';\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\n결과를 5개 얻게되지만, 레코드 #752은 결과값 어디에도 존재하지 않는다. 이유는 null&lt;'1930-00-00' 평가결과가 참도 거짓도 아니기 때문이다. null 이 의미하는 것은 “알수가 없다”는 것이다. 그리고 만약 비교 평가식의 왼쪽편 값을 알지 못한다면, 비교도 참인지 거짓인지 알수가 없다. 데이터베이스는 “알 수 없음”을 null로 표현하기 때문에, null&lt;'1930-00-00'의 값도 사실 null이다. null&gt;='1930-00-00'도 또한 null인데 왜냐하면 질문에 답을 할 수 없기 때문이다. 그리고, where절에 레코드는 테스트가 참인 것만 있기 때문에 레코드 #752은 어느 결과값에도 포함되지 않게 된다.\n평가식만 null값을 이와 같은 방식으로 다루는 연산자는 아니다. 1+null도 null이고, 5*null도 null이고, log(null)도 null이 된다. 특히, 무언가를 = 과 != 으로 null과 비교하는 것도 null이 된다.\n%%sqlite survey.db\nselect * from Visited where dated=NULL;\n\n\n\n\n%%sqlite survey.db\nselect * from Visited where dated!=NULL;\n\n\n\n\nnull 인지 아닌지를 점검하기 위해서, 특별한 테스트 is null을 사용해야 한다.\n%%sqlite survey.db\nselect * from Visited where dated is NULL;\n\n\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\n혹은, 역으로는 is not null을 사용한다.\n%%sqlite survey.db\nselect * from Visited where dated is not NULL;\n\n\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nnull 값은 나타나는 곳마다 두통을 일으킨다. 예를 들어, Dyer가 측정하지 않은 모든 염분 정보를 찾는다고 가정하자. 다음과 같이 쿼리를 작성하는 것은 당연하다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and person!='lake';\n\n\n\n\n619\n\n\ndyer\n\n\nsal\n\n\n0.13\n\n\n\n\n622\n\n\ndyer\n\n\nsal\n\n\n0.09\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n하지만, 상기 쿼리 필터는 누가 측정을 했는지 모르는 레코드는 빠뜨린다. 다시 한번, 이유는 person이 null일 때, !=비교는 null값을 만들어서 레코드가 결과값에 있지 않게 된다. 만약 이런 레코드도 유지하려고 한다면, 명시적으로 검사를 추가할 필요가 있다.\n%%sqlite survey.db\nselect * from Survey where quant='sal' and (person!='lake' or person is null);\n\n\n\n\n619\n\n\ndyer\n\n\nsal\n\n\n0.13\n\n\n\n\n622\n\n\ndyer\n\n\nsal\n\n\n0.09\n\n\n\n\n735\n\n\nNone\n\n\nsal\n\n\n0.06\n\n\n\n\n752\n\n\nroe\n\n\nsal\n\n\n41.6\n\n\n\n\n837\n\n\nroe\n\n\nsal\n\n\n22.5\n\n\n\n\n여전히 이러한 접근법이 맞는 것인지 아닌 것인지 판단할 필요가 있다. 만약 절대적으로 결과에 Lake가 측정한 어떠한 값도 포함하지 않는다고 확신한다면, 누가 작업을 한 것인지 모르는 모든 레코드를 제외할 필요가 있다.\n\n도전 과제\n\n날짜가 알려지지 않은 (즉 null) 항목은 빼고, 날짜 순으로 Visited 테이블에 있는 레코드를 정렬한 쿼리를 작성하세요.\n다음 쿼리가 무슨 결과를 할까요?\nselect * from Visited where dated in ('1927-02-08', null);\n상기 쿼리가 실질적으로 무엇을 생기게 할까요?\n몇몇 데이터베이스 디자이너는 null 보다 결측 데이터를 표기하기 위해서 보초값(sentinel value)를 사용한다. 예를 들어, 결측 날짜를 표기하기 위해서 “0000-00-00” 날짜를 사용하거나 결측 염분치 혹은 결측 방사선 측정값을 표기하기 위해서 -1.0을 사용한다. (왜냐하면 실제 측정값이 음수가 될 수 없기 때문이다.) 이러한 접근법은 무엇을 단순화할까요? 이러한 접근법이 어떤 부담과 위험을 가져올까요?\n\n\n\n주요점\n\n데이터베이스는 결측 정보를 표현하기 위해서 null을 사용한다.\nnull이 관계되는 산술 혹은 불 연산 결과도 null이다.\nnull과 함께 안전하세 사용될 수 있는 유일한 연산자는 is null과 is not null이다."
  },
  {
    "objectID": "06-agg.html",
    "href": "06-agg.html",
    "title": "7  집합(Aggregation)",
    "section": "",
    "text": "목표\n\n“집합(aggregation)을 정의하고 사용예를 제시한다.\n집합하는 값을 계산하는 쿼리를 작성한다.\n집합을 수행하는 쿼리의 실행을 추적한다.\n결측 데이터가 어떻게 집합되는 동안에 다뤄지는지 설명한다.\n\n\n이제 데이터의 평균과 범위를 계산하고자 한다. Visited 테이블에서 모든 날짜 정보를 어떻게 선택하는지 알고 있다.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect dated from Visited;\n\n\n\n\n1927-02-08\n\n\n\n\n1927-02-10\n\n\n\n\n1939-01-07\n\n\n\n\n1930-01-12\n\n\n\n\n1930-02-26\n\n\n\n\nNone\n\n\n\n\n1932-01-14\n\n\n\n\n1932-03-22\n\n\n\n\n하지만 조합하기 위해서는 min 혹은 max 같은 집합 함수(aggregation function)를 사용해야만 한다. 각 함수는 입력으로 레코드 집합을 받고 출력으로 단일 레코드를 만든다.\n%%sqlite survey.db\nselect min(dated) from Visited;\n\n\n\n\n1927-02-08\n\n\n\n\n\n%%sqlite survey.db\nselect max(dated) from Visited;\n\n\n\n\n1939-01-07\n\n\n\n\nmin과 max는 SQL에 내장된 단지 두개의 집합 함수다. 다른 세개는 avg, count, sum이 있다.\n%%sqlite survey.db\nselect avg(reading) from Survey where quant='sal';\n\n\n\n\n7.20333333333\n\n\n\n\n%%sqlite survey.db\nselect count(reading) from Survey where quant='sal';\n\n\n\n\n9\n\n\n\n\n%%sqlite survey.db\nselect sum(reading) from Survey where quant='sal';\n\n\n\n\n64.83\n\n\n\n\n여기서 count(reading)을 사용했다. 하지만 quant를 단순히 쉽게 세거나 테이블의 다른 어떤 필드도 셀 수 있고 심지어 count(*)을 사용하기도 한다. 왜냐하면 count()함수가 값 자체보다는 얼마나 많은 값이 있는지에만 관심을 두기 때문이다.\nSQL이 여러개의 집합연산도 한번에 수행한다. 예를 들어, 염분측정치의 범위도 알 수 있다.\n%%sqlite survey.db\nselect min(reading), max(reading) from Survey where quant='sal' and reading&lt;=1.0;\n\n\n\n\n0.05\n\n\n0.21\n\n\n\n\n출력결과가 놀라움을 줄 수도 있지만, 원 결과값과 집합 결과를 조합할 수도 있다.\n%%sqlite survey.db\nselect person, count(*) from Survey where quant='sal' and reading&lt;=1.0;\n\n\n\n\nlake\n\n\n7\n\n\n\n\n왜 Roerich 혹은 Dyer가 아닌 Lake의 이름이 나타날까요? 답은 필드를 집합하지만 어떻게 집합하는지 말을 하지 않기 때문에 데이터베이스 관리자가 입력에서 실제 값을 고른다. 처음 처리된 것, 마지막에 처리된 것, 혹은 완전히 다른 무언가를 사용할 수도 있다.\n또다른 중요한 사실은 집합할 어떠한 값도 없을 때, 집합 결과는 0 혹은 다른 임의의 값 보다 “알지 못한다(don’t know)”가 된다.\n%%sqlite survey.db\nselect person, max(reading), sum(reading) from Survey where quant='missing';\n\n\n\n\nNone\n\n\nNone\n\n\nNone\n\n\n\n\n집합 함수의 마지막 중요한 한가지 기능은 매우 유용한 방식으로 나머지 SQL과는 일관되지 않다는 것이다. 만약 두 값을 더하는데 그중 하나가 null이면 결과는 null이다. 확장해서, 만약 한 집합의 모든 값을 더하기 위해서 sum을 사용하고 이들 중 임의의 값이 null이면, 결과도 또한 null이어야 한다. 하지만 집합함수가 null 값을 무시하고 단지 non-null 값만을 조합한다면 훨씬 더 유용하다. 명시적으로 항상 필터해야하는 대신에 이것의 결과 쿼리를 다음과 같이 작성할 수 있게 한다.\n%%sqlite survey.db\nselect min(dated) from Visited;\n\n\n\n\n1927-02-08\n\n\n\n\n명시적으로 항상 다음과 같이 필터하는 쿼리를 작성할 필요가 없다.\n%%sqlite survey.db\nselect min(dated) from Visited where dated is not null;\n\n\n\n\n1927-02-08\n\n\n\n\n한번에 모든 레코드를 집합하는 것이 항상 타당하지는 않다. 예를 들어, Gina가 데이터에 체계적인 편의(bias)가 있어서 다른 과학자의 방사선 측정치가 다른 사람의 것과 비교하여 높다고 의심한다고 가정하자. 다음 쿼리가 의도를 반영하여 동작하지 않는다는 것은 알고 있다.\n%%sqlite survey.db\nselect person, count(reading), round(avg(reading), 2)\nfrom  Survey\nwhere quant='rad';\n\n\n\n\nroe\n\n\n8\n\n\n6.56\n\n\n\n\n왜냐하면 데이터베이스 관리자가 각 과학자별로 구분된 집합하기 보다는 임의의 한명의 과학자 이름만 선택하기 때문이다. 단지 5명의 과학자만 있기 때문에, 다음과 같은 형식의 5개 쿼리를 작성할 수 있다.\n%%sqlite survey.db\nselect person, count(reading), round(avg(reading), 2)\nfrom  Survey\nwhere quant='rad'\nand   person='dyer';\n\n\n\n\ndyer\n\n\n2\n\n\n8.81\n\n\n\n\n하지만, 이러한 접근법은 성가시고, 만약 50명 혹은 500명의 과학자를 가진 데이터셋을 분석한다면, 모든 쿼리를 올바르게 작성할 가능성은 작다.\n필요한 것은 데이터베이스 관리자가 group by절을 사용해서 각 과학자별로 시간을 집합하도록 지시하는 것이다.\n%%sqlite survey.db\nselect   person, count(reading), round(avg(reading), 2)\nfrom     Survey\nwhere    quant='rad'\ngroup by person;\n\n\n\n\ndyer\n\n\n2\n\n\n8.81\n\n\n\n\nlake\n\n\n2\n\n\n1.82\n\n\n\n\npb\n\n\n3\n\n\n6.66\n\n\n\n\nroe\n\n\n1\n\n\n11.25\n\n\n\n\ngroup by는 이름이 의미하는 것과 동일한 것을 정확하게 수행한다. 지정된 필드에 동일한 값을 가진 모든 레코드를 그룹으로 묶어서 집합을 각 배치별로 처리한다. 각 배치에 모든 레코드는 person에 동일한 값을 가지고 있기 때문에, 데이터베이스 관리자가 임의의 값을 잡아서 집합된 reading 값과 함께 표시하는지는 더 이상 문제가 되지 않는다.\n한번에 다중 기준으로 정렬하듯이 다중 기준으로 묶어 그룹화할 수 있다. 예를 들어 과학자와 측정 수량에 따라 평균 측정값을 얻기 위해서, group by 절에 또다른 필드만 추가한다.\n%%sqlite survey.db\nselect   person, quant, count(reading), round(avg(reading), 2)\nfrom     Survey\ngroup by person, quant;\n\n\n\n\nNone\n\n\nsal\n\n\n1\n\n\n0.06\n\n\n\n\nNone\n\n\ntemp\n\n\n1\n\n\n-26.0\n\n\n\n\ndyer\n\n\nrad\n\n\n2\n\n\n8.81\n\n\n\n\ndyer\n\n\nsal\n\n\n2\n\n\n0.11\n\n\n\n\nlake\n\n\nrad\n\n\n2\n\n\n1.82\n\n\n\n\nlake\n\n\nsal\n\n\n4\n\n\n0.11\n\n\n\n\nlake\n\n\ntemp\n\n\n1\n\n\n-16.0\n\n\n\n\npb\n\n\nrad\n\n\n3\n\n\n6.66\n\n\n\n\npb\n\n\ntemp\n\n\n2\n\n\n-20.0\n\n\n\n\nroe\n\n\nrad\n\n\n1\n\n\n11.25\n\n\n\n\nroe\n\n\nsal\n\n\n2\n\n\n32.05\n\n\n\n\n그렇지 않으면 결과가 의미가 없기 때문에, person을 표시되는 필드 리스트에 추가한 것을 주목하라.\n한단계 더나아가 누가 측정을 했는지 알지 못하는 모든 항목을 제거하자.\n%%sqlite survey.db\nselect   person, quant, count(reading), round(avg(reading), 2)\nfrom     Survey\nwhere    person is not null\ngroup by person, quant\norder by person, quant;\n\n\n\n\ndyer\n\n\nrad\n\n\n2\n\n\n8.81\n\n\n\n\ndyer\n\n\nsal\n\n\n2\n\n\n0.11\n\n\n\n\nlake\n\n\nrad\n\n\n2\n\n\n1.82\n\n\n\n\nlake\n\n\nsal\n\n\n4\n\n\n0.11\n\n\n\n\nlake\n\n\ntemp\n\n\n1\n\n\n-16.0\n\n\n\n\npb\n\n\nrad\n\n\n3\n\n\n6.66\n\n\n\n\npb\n\n\ntemp\n\n\n2\n\n\n-20.0\n\n\n\n\nroe\n\n\nrad\n\n\n1\n\n\n11.25\n\n\n\n\nroe\n\n\nsal\n\n\n2\n\n\n32.05\n\n\n\n\n좀더 면밀하게 살펴보면, 이 쿼리는,\n\nSurvey테이블에서 person 필드가 null이 아닌 레코드를 선택한다.\n상기 레코드를 부분집합으로 그룹지어서 각 부분집합의 person과 quant의 값은 같다.\n먼저 person으로 부분집합을 정렬하고나서 quant로 각 하위 그룹내에서도 정렬한다.\n각 부분집합의 레코드 숫자를 세고, 각각 reading 평균을 계산하고, 각각 person과 quant 값을 선택한다. (모두 동등하기 때문에 어느 것인지는 문제가 되지 않는다.)\n\n\n도전 과제\n\nFrank Pabodie는 얼마 많이 온도 측정치를 기록했고 평균 값은 얼마인가요?\n집합 값의 평균은 값을 합한 것을 값의 갯수로 나눈 것이다. 값이 1.0, null, 5.0 으로 주어졌을 때, avg 함수는 2.0 혹은 3.0을 반환하는 것을 의미하나요?\n각 개별 방사선 측정값과 평균값 사이의 차이를 계산하고자 한다. 쿼리를 다음과 같이 작성한다.\nselect reading - avg(reading) from Survey where quant='rad';\n상기 쿼리가 무엇을 만드나요? 그리고 왜 그런가요?\ngroup_concat(field, separator) 함수는 지정된 구분 문자(혹은 만약 구분자가 지정되지 않는다면 ‘,’)를 사용하여 필드의 모든 값을 결합한다. 이 함수르 사용해서 과학자의 이름을 한줄 리스트로 다음과 같이 만드세요.\nWilliam Dyer, Frank Pabodie, Anderson Lake, Valentina Roerich, Frank Danforth\n성씨(surname)으로 리스트를 정렬하는 방법을 제시할 수 있나요?\n\n\n\n주요점\n\n집합 함수는 많은 값을 조합해서 하나의 새로운 값을 만든다.\n집합 함수는 null 값을 무시한다.\n필터링 다음에 집합이 일어난다."
  },
  {
    "objectID": "07-join.html",
    "href": "07-join.html",
    "title": "8  데이터 조합하기 (Combining Data)",
    "section": "",
    "text": "목표\n\n두 테이블을 조인(join)하는 쿼리 연산을 설명한다.\n의미있는 값의 조합만 포함하기 위해서 조인문을 포함하는 쿼리 결과를 어떻게 제한하는지 설명한다.\n동일한 키를 갖는 테이블을 조인하는 쿼리를 작성한다.\n기본키(primary key)와 외래키(foreign key)가 무엇인지 그리고 왜 유용한지 설명한다.\n원자값(atomic value)이 무엇이고, 왜 데이터베이스 필드는 원자값만 포함해야하는지 설명한다.\n\n\n과거 기상 자료를 집계하는 웹사이트에 데이터를 제출해야 되어서, Gina는 위도, 경도, 날짜, 수량, 측정값 형식으로 자료를 체계적으로 만들 필요가 있다. 하지만, 위도와 경도 정보는 Site 테이블에 있는 반면에 측정 날짜 정보는 Visited 테이블에 있고, 측정값 자체는 Survey 테이블에 있다. 어떤 방식이든지 상기 테이블을 조합할 필요가 있다.\n이러한 작업을 하는 SQL 명령어가 join이다. 어떻게 동작하는지 확인하기 위해서, Site와 Visited 테이블을 조인하면서 출발해보자.\n%load_ext sqlitemagic\n%%sqlite survey.db\nselect * from Site join Visited;\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\njoin은 두 테이블을 외적(cross product)한다. 즉, 모든 가능한 조합을 표현하려고 한 테이블의 레코드 각각마다 다른 테이블의 각 레코드와 조인한다. Site 테이블에 3개 레코드가 있고, Visited 테이블에 8개 레코드가 있어서, 조인된 결과는 24개 레코드가 된다. 그리고, 각 테이블이 3개 필드가 있어서 출력은 6개의 필드가 된다.\n조인이 수행하지 않은 것은 조인되는 레코드가 서로 관계가 있는지를 파악하는 것이다. 어떻게 조인할지 명시할 때까지 레코드가 서로 관계가 있는지 없는지 알 수 있는 방법은 없다. 이를 위해서 동일한 사이트 이름을 가진 조합에만 관심있다는 것을 명시하는 절(clause)을 추가한다.\n%%sqlite survey.db\nselect * from Site join Visited on Site.name=Visited.site;\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n619\n\n\nDR-1\n\n\n1927-02-08\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n622\n\n\nDR-1\n\n\n1927-02-10\n\n\n\n\nDR-1\n\n\n-49.85\n\n\n-128.57\n\n\n844\n\n\nDR-1\n\n\n1932-03-22\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n734\n\n\nDR-3\n\n\n1939-01-07\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n735\n\n\nDR-3\n\n\n1930-01-12\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n751\n\n\nDR-3\n\n\n1930-02-26\n\n\n\n\nDR-3\n\n\n-47.15\n\n\n-126.72\n\n\n752\n\n\nDR-3\n\n\nNone\n\n\n\n\nMSK-4\n\n\n-48.87\n\n\n-123.4\n\n\n837\n\n\nMSK-4\n\n\n1932-01-14\n\n\n\n\non 은 where와 같은 역할을 한다. 특정 테스트를 통과한 레코드만 간직한다. (on과 where의 차이점은 on은 레코드가 생성될 때 레코드를 필터링하는 반면에, where는 조인작업이 완료될 때까지 기다리고 난 뒤에 필터링을 한다.) 쿼리에 레코드를 추가하자 마자 데이터베이스 관리자는 두 다른 사이트에 관한 조합된 정보는 사용한 뒤에 버려버리고, 원하는 레코드만 남겨둔다.\n조인 결과에 필드이름을 명기하기 위해서 table.field를 사용한 것에 주목하세요. 이렇게 하는 이유는 테이블이 동일한 이름을 가질 수 있고 어느 필드를 언급하는지 좀더 구체성을 띌 필요가 있다. 예를 들어, person과 visited 테이블을 조인한다면, 결과는 각각의 원래 테이블에서 ident로 불리는 필드를 상속한다.\n이제는 조인에서 원하는 3개의 칼럼을 선택하려고 점 표기법(dotted notation)을 사용할 수 있다.\n%%sqlite survey.db\nselect Site.lat, Site.long, Visited.dated\nfrom   Site join Visited\non     Site.name=Visited.site;\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1932-03-22\n\n\n\n\n-47.15\n\n\n-126.72\n\n\nNone\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\n\n\n만약 두개의 테이블을 조인하는 것이 좋은 경우에, 많은 데이블을 조인하는 것은 더 좋아야한다. 더 많은 join 절과 의미없는 레코드 조합을 필터링해서 제거하는 더 많은 on 테스트를 단순히 추가해서 사실 쿼리에 임의 갯수의 테이블을 조인할 수 있다.\n%%sqlite survey.db\nselect Site.lat, Site.long, Visited.dated, Survey.quant, Survey.reading\nfrom   Site join Visited join Survey\non     Site.name=Visited.site\nand    Visited.ident=Survey.taken\nand    Visited.dated is not null;\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\nrad\n\n\n9.82\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\nsal\n\n\n0.13\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\nrad\n\n\n7.8\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\nsal\n\n\n0.09\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\nrad\n\n\n8.41\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\nsal\n\n\n0.05\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\ntemp\n\n\n-21.5\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\nrad\n\n\n7.22\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\nsal\n\n\n0.06\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\ntemp\n\n\n-26.0\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\nrad\n\n\n4.35\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\nsal\n\n\n0.1\n\n\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\ntemp\n\n\n-18.5\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\nrad\n\n\n1.46\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\nsal\n\n\n0.21\n\n\n\n\n-48.87\n\n\n-123.4\n\n\n1932-01-14\n\n\nsal\n\n\n22.5\n\n\n\n\n-49.85\n\n\n-128.57\n\n\n1932-03-22\n\n\nrad\n\n\n11.25\n\n\n\n\nSite, Visited, Survey 테이블의 어느 레코드가 서로 대응되지는 분간할 수 있는데 이유는 각 테이블이 기본키(primary keys)와 외래키(foreign keys)를 가지고 있기 때문이다.. 기본키는 하나의 값 혹은 여러 값의 조합으로 테이블의 각 레코드를 유일하게 식별한다. 외래키는 또 다른 테이블에 있는 유일하게 레코드를 식별하는 하나의 값(혹은 여러 값의 조합)이다. 다르게 표현하면, 외래캐는 다른 테이블에 존재하는 테이블의 기본키다. 예제 데이터베이스에서 Person.ident는 Person 테이블의 기본키인 반면에, Survey.person은 외래키로 Survey 테이블의 항목과 Person 테이블의 항목을 연결한다.\n대부분의 데이터베이스 디자이너는 모든 테이블은 잘 정의된 기본키가 있어야된다고 믿는다. 또한 이 키는 데이터와 떨어져서 만약 데이터를 변경할 필요가 있다면, 한 곳의 변경이 한 곳에만 변경을 만들어야만 한다. 이를 위한 쉬운 방법은 데이터베이스에 레코드를 추가할 때 임의의 유일한 ID를 각 레코드마다 추가하는 것이다. 실제로 이방법은 매우 흔하게 사용된다. “student numbers”, “patient numbers” 같은 이름을 ID로 사용하고, 몇몇 데이터베이스 시스템 혹은 다른 곳에서 원래 고유 레코드 식별자로 거의 항상 판명된다. 다음 쿼리가 시범으로 보여주듯이, 테이블에 레코드가 추가됨에 따라 SQLite는 자동으로 레코드에 숫자를 붙이고, 쿼리에서 이렇게 붙여진 레코드 숫자를 사용한다.\n%%sqlite survey.db\nselect rowid, * from Person;\n\n\n\n\n1\n\n\ndyer\n\n\nWilliam\n\n\nDyer\n\n\n\n\n2\n\n\npb\n\n\nFrank\n\n\nPabodie\n\n\n\n\n3\n\n\nlake\n\n\nAnderson\n\n\nLake\n\n\n\n\n4\n\n\nroe\n\n\nValentina\n\n\nRoerich\n\n\n\n\n5\n\n\ndanforth\n\n\nFrank\n\n\nDanforth\n\n\n\n\n\n8.0.1 데이터 위생 (Data Hygiene)\n지금까지 조인이 어떻게 동작하는지 살펴봤으니, 왜 관계형 모델이 그렇게 유용한지 그리고 어떻게 가장 잘 사용할 수 있는지 살펴보자. 첫번째 규칙은 모든 값은 독립 요소로 분해될 수 없는 원자(atomic)적 속성을 지녀야 한다. 즉, 구별해서 작업하고자 하는 부분을 포함해서는 안된다. 하나의 칼럼에 전체 이름을 넣는 대신에 별도로 구별되는 칼럼에 이름과 성을 저장해서 이름 컴포넌트를 뽑아내는 부분 문자열 연산(substring operation)을 사용할 필요가 없다. 좀더 중요하게는, 별도로 이름을 두 부분으로 저장한다. 왜냐하면, 공백으로 쪼개는 것은 신뢰성이 약하다. “Eloise St. Cyr” 혹은 “Jan Mikkel Steubart” 같은 이름을 생각하면 쉽게 알 수 있다.\n두번째 규칙은 모든 레코드는 유일한 기본키를 가져야한다. 내재적인 의미가 전혀없는 일련번호가 될 수 있고, 레코드의 값중의 하나 (Person 테이블의 ident 필드), 혹은 Survey 테이블에서 심지어 모든 측정값을 유일하게 식별하는 (taken, person, quant) 삼중값의 조합도 될 수 있다.\n세번째 규칙은 불필요한 정보가 없어야 한다. 예를 들어, Site테이블을 제거하고 다음과 같이 Visited 테이블을 다시 작성할 수 있다.\n\n\n\n619\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-08\n\n\n\n\n622\n\n\n-49.85\n\n\n-128.57\n\n\n1927-02-10\n\n\n\n\n734\n\n\n-47.15\n\n\n-126.72\n\n\n1939-01-07\n\n\n\n\n735\n\n\n-47.15\n\n\n-126.72\n\n\n1930-01-12\n\n\n\n\n751\n\n\n-47.15\n\n\n-126.72\n\n\n1930-02-26\n\n\n\n\n752\n\n\n-47.15\n\n\n-126.72\n\n\nnull\n\n\n\n\n837\n\n\n-48.87\n\n\n-123.40\n\n\n1932-01-14\n\n\n\n\n844\n\n\n-49.85\n\n\n-128.57\n\n\n1932-03-22\n\n\n\n사실, 스프레드쉬트와 마찬가지로 각 행에 각 측정값에 관한 모든 정보를 기록하는 하나의 테이블을 사용할 수도 있다. 문제는 이와 같은 방식으로 조직된 데이터를 일관성있게 관리하는 것은 매우 어렵다. 만약 특정한 사이트의 특정한 방문 날짜가 잘못된다면, 데이터베이스에 다수의 레코드를 변경해야한다. 더 안좋은 것은 다른 사이트도 그 날짜에 방문되었기 때문에 어느 레코드를 변경할지 추정해야하는 것이다.\n네번째 규칙은 모든 값의 단위는 명시적으로 저장되어야한다. 예제 데이터베이스는 그렇지 못해서 문제다.\nRoerich의 염분치는 다른 사람의 측정치보다 수천배 크다. 하지만, 천단위 대신에 백만 단위를 사용하고 있는지 혹은 1932년 그 사이트에 염분에 이상 실제로 있었는지 알지못한다.\n한걸음 물러나서 생각하자, 데이터와 저장하는데 사용되는 도구는 공생관계다. 테이블과 조인은 데이터가 특정 방식으로 잘 조직되었다면 매우 효과적이다. 하지만, 만약 특정 형태로 되어 있다면 효과적으로 다룰 수 있는 도구가 있기 때문에 데이터를 그와 같은 방식으로 조직하기도 한다. 인류학자가 말했듯이, 도구는 도구를 만드는 손을 만든다. (the tool shapes the hand that shapes the tool)\n\n도전 과제\n\nDR-1 사이트의 모든 방사선 측정치를 출력하는 쿼리를 작성하세요.\n“Frank” 가 방문한 모든 사이트를 출력하는 쿼리를 작성하세요.\n다음 쿼리가 무슨 결과를 산출하는지 말로 기술하세요.\nselect Site.name from Site join Visited\non Site.lat&lt;-49.0 and Site.name=Visited.site and Visited.dated&gt;='1932-00-00';\n\n\n\n주요점\n\n모든 사실은 데이터베이스에서 정확하게 한번만 표현되어야 한다.\n조인은 한 테이블의 레코드와 다른 테이블의 레코드를 모두 조합한 결과를 출력한다.\n기본키는 테이블의 레코드를 유일하게 식별하는 필드값(혹은 필드의 집합)이다.\n외래키는 또 다른 테이블의 기본키가되는 필드값(혹은 필드의 집합)이다.\n테이블사이에 기본키와 외래키를 매칭해서 의미없는 레코드의 조합을 제거할 수 있다.\n조인을 좀더 단순하고 효율적으로 만들기 위해서 키(key)는 원자값(atomic value)이 되어야 한다."
  },
  {
    "objectID": "08-create.html",
    "href": "08-create.html",
    "title": "9  데이터 생성과 변형(Creating and Modifying Data)",
    "section": "",
    "text": "목표\n\n테이블을 생성하는 쿼리를 작성한다.\n레코드를 삽입, 변형, 삭제하는 쿼리를 작성한다.\n\n\n지금까지 어떻게 데이터베이스에서 정보를 추출하는지만 살펴봤다. 왜냐하면, 정보를 추가하는 것보다 정보를 조회하는 것이 더 자주 있는 일이기도 하고, 다른 연산자는 쿼리가 이해되어야만 의미가 통하기 때문이다. 만약 데이터를 생성하고 변형하고자 한다면, 다른 두짝의 명령어를 공부할 필요가 있다.\n첫번째 짝은 create table과 drop table이다. 두 단어로 작성되지만, 사실 하나의 단일 명령어다. 첫번째 명령어는 새로운 테이블을 생성한다. 인자는 테이블 칼럼의 이름과 형식이다. 예를 들어, 다음 문장은 survey 데이터베이스에 테이블 4개를 생성한다.\ncreate table Person(ident text, personal text, family text);\ncreate table Site(name text, lat real, long real);\ncreate table Visited(ident integer, site text, dated text);\ncreate table Survey(taken integer, person text, quant real, reading real);\n다음 명령어를 사용하여 테이블 중의 하나를 제거할 수도 있다.\ndrop table Survey;\n데이블을 제거할 때 매우 주의하라. 대부분의 데이터베이이스는 변경사항을 되돌리는 기능을 제공하지만, 이러한 기능에 의존하지 않는 것이 더 낫다.\n다른 데이터베이스 시스템은 테이블 칼럼의 다른 데이터 형식도 지원하지만, 대부분은 다음을 다음을 제공한다.\n\n\n\ninteger\n\n\n부호있는 정수형\n\n\n\n\nreal\n\n\n부동 소수점 실수\n\n\n\n\ntext\n\n\n문자열\n\n\n\n\nblob\n\n\n이미지 같은 “이진 대형 개체”\n\n\n\n대부분의 데이터베이스는 불(boolean)과 날짜/시간 값도 지원한다. SQLite는 불값을 정수 0 과 1 을 사용하고 날짜/시간은 앞선(earlier) 학습방식으로 표현한다. 점점 더 많은 데이터베이스가 위도와 경도 같은 지리정보 데이터 형식도 지원한다. 특정 시스템이 무슨 기능을 제공하고 제공하지 않는지 그리고 어떤 이름을 다른 데이터 형식에 부여하는지를 계속 파악하는 것은 끝없는 시스템 이식성에 대한 골치거리다.\n테이블을 생성할 때, 칼럼에 몇가지 제약사항을 지정할 수 있다. 예를 들어, Survey 테이블에 대한 좀더 좋은 정의는 다음과 같이 될 것이다.\ncreate table Survey(\n    taken   integer not null, -- where reading taken\n    person  text,             -- may not know who took it\n    quant   real not null,    -- the quantity measured\n    reading real not null,    -- the actual reading\n    primary key(taken, quant),\n    foreign key(taken) references Visited(ident),\n    foreign key(person) references Person(ident)\n);\n다시 한번, 정확하게 무슨 제약사항이 이용가능하고 어떻게 호출되는지는 어떤 데이터베이스 관리자를 사용하는야에 달려있다.\n테이블이 생성되자마자, 다른 명령어 짝 insert와 delete를 사용하여 레코드를 추가하고 제거할 수 있다. insert 문의 가장 간단한 형식은 순서대로 값을 목록으로 나열하는 것이다.\ninsert into Site values('DR-1', -49.85, -128.57);\ninsert into Site values('DR-3', -47.15, -126.72);\ninsert into Site values('MSK-4', -48.87, -123.40);\n또한, 다른 테이블에서 직접 값을 테이블에 삽입할 수도 있다.\ncreate table JustLatLong(lat text, long text);\ninsert into JustLatLong select lat, long from site;\n레코드를 삭제하는 것은 약간 난이도가 있다. 왜냐하면, 데이터베이스가 내부적으로 일관성을 보장할 필요가 있기 때문이다. 만약 하나의 단독 테이블만 관심을 둔다면, 삭제하고자 하는 레코드와 매칭되는 where절과 delete문을 함께 사용한다. 예를 들어, Frank Danforth가 어떤 측정도 하지 않았다는 것을 인지하자마자, 다음과 같이 Person 테이블에서 Frank Danforth를 제거할 수 있다.\ndelete from Person where ident = \"danforth\";\n하지만 대신에 Anderson Lake를 실수로 제거했다면 어떨까요? Survey 테이블은 Anderson Lake이 수행한 7개의 측정 레코드를 담고 있지만, 이것은 결코 일어나지 말아야 된다. Survey.person은 Person 테이블에 외래키이고, 모든 쿼리는 전자의 모든 값을 매칭하는 후자의 행이 있을 거라고 가정한다.\n이러한 문제를 참조 무결성(referential integrity)이라고 부른다. 테이블 사이의 모든 참조는 항상 제대로 해결될 수 있도록 확인할 필요가 있다. 참조 무결성을 보증하는 한 방법은 기본키로 사용하는 레코드를 삭제하기 전에 외래키로 'lake'를 사용하는 모든 레코드를 삭제하는 것이다. 만약 데이터베이스 관리자가 이 기능을 지원한다면, 연쇄적인 삭제(cascading delete)를 사용해서 자동화할 수 있다. 하지만, 이 기법은 여기서 다루는 학습 영역밖이다.\n\n모든 것을 데이터베이스에 저장하는 대신 많은 응용프로그램은 하이브리드 저장 모델을 사용한다. 천체 이미지 같은 실제 데이터는 파일에 저장되는 반면에, 파일 이름, 변경된 날짜, 커버하는 하늘의 영역, 스펙트럼 특성, 등등 정보는 데이터베이스에 저장한다. 대부분의 음악 재생기(MP3 플레이어) 소프트웨어가 작성되는 방식이기도 하다. 응용프로그램 내부 데이터베이스는 MP3 파일을 기억하고 있지만, MP3 파일 자체는 디스크에 있다.\n\n\n도전 과제\n\nSurvey.person의 null인 모든 사용자를 문자열 'unknown'으로 대체하는 SQL문을 작성하세요.\n동료중의 한명이 Robert Olmstead가 측정한 온도 측정치를 포함하는 다음과 같은 형식의 CSV 파일을 보내왔다.\nTaken,Temp\n619,-21.5\n622,-15.5\nsurvey 데이터베이스에 레코드로 추가하려고 CSV 파일을 읽고 SQL insert문을 출력하는 작은 파이썬 프로그램을 작성하세요. Person 테이블에 Olmstead 항목을 추가할 필요가 있을 것이다. 반복적으로 프로그램을 테스트하려면, SQL insert or replace 문을 자세히 살펴볼 필요도 있다.\nSQLite는 SQL 표준이 아닌 몇개 관리 명령어가 있다. 그중의 하나가 .dump로 데이터베이스를 다시 생성하는데 필요한 SQL 명령문을 출력한다. 또다른 것은 .load로 .dump에서 생성된 파일을 읽어서 데이터베이스를 복원한다. 여러분의 동료중의 한명이 텍스트인 dump 파일을 버젼 제어 시스템에 저장하는 것이 데이터베이스 변경사항을 추적하고 관리하는 좋은 방법이라고 생각한다. 이러한 접근법의 장점과 단점은 무엇일까요? (힌트: 레코드는 어느 특정한 순서로 저장되지 않는다.)\n\n\n\n주요점\n\n데이터베이스 테이블은 테이블 이름과 필드의 이름과 특성을 명시하는 쿼리를 사용해서 생성된다.\n쿼리를 사용해서 레코드는 삽입, 갱신, 삭제될 수 있다.\n모든 레코드가 유일한 기본키를 가질 때 데이터를 변경하는 것이 더 간단하고 안전하다."
  },
  {
    "objectID": "09-prog.html",
    "href": "09-prog.html",
    "title": "10  데이터베이스로 프로그래밍",
    "section": "",
    "text": "목표\n\nSQL 쿼리를 실행하는 짧은 프로그램을 작성한다.\nSQL 쿼리를 포함하는 프로그램의 실행을 추적한다.\n왜 대부분의 데이터베이스 응용프로그램이 SQL 보다 다른 범용 언어로 작성되는지 설명한다.\n\n\n마무리 하면서, 파이썬 같은 범용 프로그래밍 언어에서 데이터베이스를 어떻게 접근하는지 삺펴보자. 다른 언어도 거의 같은 모델을 사용한다. 라이브러리와 함수 이름이 다를지 모르지만, 개념은 동일한다.\nsurvey.db라는 이름의 파일에 저장된 SQLite 데이터베이스에서 위도와 경도를 선택하는 짧은 파이썬 프로그램이 다음에 있다.\nimport sqlite3\nconnection = sqlite3.connect(\"survey.db\")\ncursor = connection.cursor()\ncursor.execute(\"select site.lat, site.long from site;\")\nresults = cursor.fetchall()\nfor r in results:\n    print r\ncursor.close()\nconnection.close()\n\n(-49.85, -128.57)\n(-47.15, -126.72)\n(-48.87, -123.4)\n\n\nsqlite3 라이브러리를 가져오는 것부터 프로그램이 시작한다. 만약 MySQL, DB2 혹은 다른 데이터베이스에 접속한다면, 다른 라이브러리를 가져올 것이지만, 동일한 기능을 제공한다. 그래서 만약 다른 이 데이터베이스에서 저 데이터베이스로 바꾼다면 프로그램의 나머지 부분은 변경할 필요(적어도 그렇게 많지는 않다.)가 었다.\n2번째 행이 데이터베이스에 연결을 설정한다. SQLite를 사용하기 때문에, 명시하는데 필요한 전부는 데이터베이스 파일 이름이다. 다른 데이터베이스 시스템은 사용자명과 비밀번호를 또한 제공하도록 요구할지도 모른다. 3번째 행은 연결을 이용하여 커서(cursor)를 생성한다. 편집기의 커서처럼, 커서의 역할은 데이터베이스에 어느 위치에 있는지 추적하는 것이다.\n4번째 행에서 커서를 사용해서 사용자를 대신해서 데이터베이스에 쿼리 실행 요청을 한다. 쿼리는 SQL로 작성되고 문자열로 cursor.execute에 전달된다. SQL이 제대로 작성되어 있는지 확실히 하는 것이 사용자의 몫이다. 만약 제대로 작성이 되어 있지 않거나 실행될 때 뭔가 잘못되었다면, 데이터베이스는 오류를 보고한다.\n5번째 행에 cursor.fetchall 호출에 응답하여 데이터베이스가 쿼리 결과를 반환한다. 결과는 결과집합에 각 레코드마다 하나의 항목을 가진 리스트다. 만약 리스트(6번째 행)를 루프 반복을 돌려서 리스트 항목(7번째 행)을 출력하면, 각각은 각 필드에 하나의 요소를 가진 튜플(tuple)인 것을 알 수 있다.\n마지막으로, 8번째와 9번째 행은 커서와 데이터베이스 연결을 종료한다. 왜냐하면 데이터베이스는 한번에 열수 있는 제한된 숫자의 연결만 유지할 수 있기 때문이다. 하지만, 연결을 설정하는 것은 시간이 소요되어서, 단지 백만분의 수초 후에 다시 연결을 하고 또 다른 작업을 하려는 연결을 하고, 작업을 하고 나서 연결을 종료하는 것은 하지 말아야 한다.\n실제 응용프로그램에서 쿼리는 사용자가 제공하는 값에 달려있다. 예를 들어, 다음 함수는 사용자의 ID를 매개변수로 받아서 이름을 반환한다.\nQueries in real applications will often depend on values provided by users. For example, this function takes a user’s ID as a parameter and returns their name:\ndef get_name(database_file, person_ident):\n    query = \"select personal || ' ' || family from Person where ident='\" + person_ident + \"';\"\n\n    connection = sqlite3.connect(database_file)\n    cursor = connection.cursor()\n    cursor.execute(query)\n    results = cursor.fetchall()\n    cursor.close()\n    connection.close()\n\n    return results[0][0]\n\nprint \"full name for dyer:\", get_name('survey.db', 'dyer')\n\nfull name for dyer: William Dyer\n\n\n함수의 첫번째 행에 문자열 결함을 사용해서 사용자가 넘겨준 사용자 ID를 포함하는 쿼리를 완성한다. 단순하게 보일지 모르지만, 만약 누군가 다음 문자열을 입력값으로 준다면 무슨일이 일어날까?\ndyer'; drop table Survey; select '\n프로젝트 이름 뒤에는 쓰레기(garbage)처럼 보이지만, 매우 주의깊게 고른 쓰레기다. 만약 이 문자열을 쿼리에 삽입하면, 결과는 다음과 같다.\nselect personal || ' ' || family from Person where ident='dyer'; drop table Survey; select '';\n만약 쿼리를 실행하게 된다면, 데이터베이스에 있는 테이블 중의 하나를 삭제한다.\n이것을 SQL 주입 공격(SQL injection attack)이라고 부른다. SQL 주입공격은 수년에 걸쳐서 수천개의 프로그램을 공격하는데 사용되었다. 특히, 많은 웹사이트가 먼저 사려깊게 입력값을 점검하지 않고 사용자에게서 데이터를 입력받는 값을 쿼리로 바로 입력한다.\n악의를 가진 사용자가 다양한 많은 방식으로 쿼리에 명령어를 몰래 밀어넣으려고 한다. 이러한 위협을 다루는 가장 안전한 방식은 인용부호 같은 문자를 대체 상응값으로 대체하는 것이다. 그렇게 해서 안전하게 문자열 내부에 사용자가 입력한 무엇이든지 넣을 수 있다. 문자열로 문장을 작성하는 대신에 준비된 문장(prepared statement)를 사용해서 작업할 수 있다. 만약에 준비된 문장을 사용한다면, 예제 프로그램은 다음과 같다.\ndef get_name(database_file, person_ident):\n    query = \"select personal || ' ' || family from Person where ident=?;\"\n\n    connection = sqlite3.connect(database_file)\n    cursor = connection.cursor()\n    cursor.execute(query, [person_ident])\n    results = cursor.fetchall()\n    cursor.close()\n    connection.close()\n\n    return results[0][0]\n\nprint \"full name for dyer:\", get_name('survey.db', 'dyer')\n\nfull name for dyer: William Dyer\n\n\n주요 변경사항은 쿼리 문자열과 execute 호출에 있다. 쿼리 자체 형식을 만드는 대신에 쿼리 템플릿에 값을 삽입하고자 하는 곳에 물음표를 넣는다. execute를 호출할 때, 쿼리의 물음표 숫자만큼의 값을 담고 있는 리스트를 제공한다. 라이브러리는 입력값을 순서대로 물음표와 매칭하고 특수 문자를 별도 상응값으로 번역해서 안전하게 사용하게 된다.\n\n도전 과제\n\n10.0 에서 25.0 사이의 100,000개 난수를 가지는 레코드를 가지고, reading으로 불리는 단일 필드를 가지고, Pressure라는 단일 테이블을 가지고, original.db이라는 이름을 가지는 신규 데이터베이스를 파일에 생성하는 파이썬 프로그램을 작성하세요.\noriginal.db과 동일한 구조를 가지는 backup.db으로 불리는 새로운 데이터베이스를 생성하는 파이썬 프로그램을 작성하세요. backup.db는 original.db에서 backup.db로 20.0보다 큰 모든 값을 복사한 값을 담고 있다. 어느 것이 더 빠른가요? 쿼리의 값을 필터링하는 것 혹은 주기억장치에 모든 것을 읽어드리고 파이썬에서 필터링하는 것 중에서 선택하세요.\n\n\n\n주요점\n\n일반적으로 범용 언어로 데이터베이스 응용프로그램을 작성하고 SQL 쿼리를 프로그램에 내장한다.\n데이터베이스에 접속하기 위해서 프로그램은 접속하려는 데이터베이스 관리자에 특정된 라이브러리를 사용해야 한다.\n프로그램은 하나 혹은 그 이상의 연결을 단일 데이터베이스에 열고, 각각에 대해서 활성화된 하나 혹은 그 이상의 커서를 가진다.\n프로그램은 쿼리 결과를 배치모드로 혹은 한번에 모두 읽어들인다."
  }
]